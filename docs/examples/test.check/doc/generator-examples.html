<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>Generator Examples</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css" /><div style="visibility: hidden;"><div class="klipse" data-external-libs="https://raw.githubusercontent.com/clojure/test.check/master/src/main/clojure">(ns my.test
                                                                  (:require [clojure.test.check :as tc :refer [quick-check]]
                                                                            [clojure.test.check.generators :as gen]
                                                                            [clojure.test.check.properties :as prop :include-macros true :refer [for-all]]))</div></div><div id="header"><h2><button id="klipse-button">InteractiveDoc</button></h2><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Test.check</span> <span class="project-version">0.9.1-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Topics</span></h3><ul><li class="depth-1 "><a href="cheatsheet.html"><div class="inner"><span>test.check cheatsheet</span></div></a></li><li class="depth-1  current"><a href="generator-examples.html"><div class="inner"><span>Generator Examples</span></div></a></li><li class="depth-1 "><a href="intro.html"><div class="inner"><span>Introduction to test.check</span></div></a></li><li class="depth-1 "><a href="migrating-from-simple-check.html"><div class="inner"><span>Migrating from simple-check</span></div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojure</span></div></div></li><li class="depth-2"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>test</span></div></div></li><li class="depth-3"><a href="clojure.test.check.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>check</span></div></a></li><li class="depth-4 branch"><a href="clojure.test.check.clojure-test.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>clojure-test</span></div></a></li><li class="depth-4 branch"><a href="clojure.test.check.generators.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>generators</span></div></a></li><li class="depth-4"><a href="clojure.test.check.properties.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>properties</span></div></a></li></ul></div><div class="document" id="content"><div class="doc"><div class="markdown"><h1><a href="#generator-examples" name="generator-examples"></a>Generator Examples</h1>
<p>The following examples assume you have the following namespace alias:</p>
<pre><code class="clojure">(require '[clojure.test.check.generators :as gen])
</code></pre>
<p>For the most part, these are in order of simplest to most complex. They also skip over some of the built-in, basic generators.</p>
<h2><a href="#integers-5-through-9-inclusive" name="integers-5-through-9-inclusive"></a>Integers 5 through 9, inclusive</h2>
<pre><code class="clojure">(def five-through-nine (gen/choose 5 9))
(gen/sample five-through-nine)
</code></pre>
<h2><a href="#a-random-element-from-a-vector" name="a-random-element-from-a-vector"></a>A random element from a vector</h2>
<pre><code class="clojure">(def languages (gen/elements ["clojure" "haskell" "erlang" "scala" "python"]))
(gen/sample languages)
</code></pre>
<h2><a href="#an-integer-or-nil" name="an-integer-or-nil"></a>An integer or nil</h2>
<pre><code class="clojure">(def int-or-nil (gen/one-of [gen/int (gen/return nil)]))
(gen/sample int-or-nil)
</code></pre>
<h2><a href="#an-integer-90-of-the-time-nil-10-" name="an-integer-90-of-the-time-nil-10-"></a>An integer 90% of the time, nil 10%</h2>
<pre><code class="clojure">(def mostly-ints (gen/frequency [[9 gen/int] [1 (gen/return nil)]]))
(gen/sample mostly-ints)
</code></pre>
<h2><a href="#even-positive-integers" name="even-positive-integers"></a>Even, positive integers</h2>
<pre><code class="clojure">(def even-and-positive (gen/fmap #(* 2 %) gen/pos-int))
(gen/sample even-and-positive 20)
</code></pre>
<h2><a href="#powers-of-two" name="powers-of-two"></a>Powers of two</h2>
<p>Let’s generate exponents with <code>gen/s-pos-int</code> (strictly positive integers), and then apply the lambda to them:</p>
<pre><code class="clojure">(def powers-of-two (gen/fmap #(int (Math/pow 2 %)) gen/s-pos-int))
(gen/sample powers-of-two)
</code></pre>
<h2><a href="#sorted-seq-of-integers" name="sorted-seq-of-integers"></a>Sorted seq of integers</h2>
<p>Here, we apply the sort function to each generated vector:</p>
<pre><code class="clojure">(def sorted-vec (gen/fmap sort (gen/vector gen/int)))
(gen/sample sorted-vec)
</code></pre>
<h2><a href="#an-integer-and-a-boolean" name="an-integer-and-a-boolean"></a>An integer and a boolean</h2>
<pre><code class="clojure">(def int-and-boolean (gen/tuple gen/int gen/boolean))
(gen/sample int-and-boolean)
</code></pre>
<h2><a href="#any-number-but-5" name="any-number-but-5"></a>Any number but 5</h2>
<pre><code class="clojure">(def anything-but-five (gen/such-that #(not= % 5) gen/int))
(gen/sample anything-but-five)
</code></pre>
<p>It’s important to note that <code>such-that</code> should only be used for predicates that are <em>very</em> likely to match. For example, you should <em>not</em> use <code>such-that</code> to filter out random vectors that are not sorted, as is this is exceedingly unlikely to happen randomly. If you want sorted vectors, just sort them using <code>gen/fmap</code> and <code>sort</code>.</p>
<h2><a href="#a-vector-and-a-random-element-from-it" name="a-vector-and-a-random-element-from-it"></a>A vector and a random element from it</h2>
<pre><code class="clojure">(def vector-and-elem (gen/bind (gen/not-empty (gen/vector gen/int))
                               #(gen/tuple (gen/return %) (gen/elements %))))
(gen/sample vector-and-elem)
</code></pre>
<p><code>gen/bind</code> and <code>gen/fmap</code> are similar: they’re both binary functions that take a generator and a function as arguments (though their argument order is reversed). They differ in what the provided function’s return value should be. The function provided to <code>gen/fmap</code> should return a <em>value</em>. We saw that earlier when we used <code>gen/fmap</code> to sort a vector. <code>sort</code> returns a normal value. The function provided to <code>gen/bind</code> should return a <em>generator</em>. Notice how above we’re providing a function that returns a <code>gen/tuple</code> generator? The decision of which to use depends on whether you want to simply transform the <em>value</em> of a generator (sort it, multiply it by two, etc.), or create an entirely new generator out of it.</p>
<hr />
<p>Go <a href="intro.html">back</a> to the intro.</p></div></div></div><script>window.klipse_settings = {
    selector: '.klipse,.clojure',
    codemirror_options_in: {
    lineWrapping: true,
    autoCloseBrackets: true
    },
    codemirror_options_out: {
    lineWrapping: true
    }
    };</script><script>
    function klipseLocalStorageEnabled() {
        var mod = 'modernizr';
        try {
          localStorage.setItem(mod, mod);
          localStorage.removeItem(mod);
          return true;
        } catch (e) {
          return false;
        }
     }
     function klipseLoad() {
      if (klipseLocalStorageEnabled()) { sessionStorage.setItem('klipse', true);}
      $('#klipse-button').remove();
      var s = document.createElement('script');
      s.setAttribute('src','https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js');
      document.head.appendChild(s);
      }
    if(!true) {
      klipseLoad();
    } else {
      if((klipseLocalStorageEnabled() && sessionStorage.getItem('klipse')) || window.location.search.match(/klipse=1/)) {
        klipseLoad();
      } else {
        $('#klipse-button').click(function(){
        klipseLoad();
       });
      }
    }
    </script></body></html>