<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><title>hickory.select documentation</title><link rel="stylesheet" type="text/css" href="css/default.css" /><link rel="stylesheet" type="text/css" href="css/highlight.css" /><script type="text/javascript" src="js/highlight.min.js"></script><script type="text/javascript" src="js/jquery.min.js"></script><script type="text/javascript" src="js/page_effects.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css" /><div style="visibility: hidden;"><div class="klipse" data-external-libs="https://raw.githubusercontent.com/davidsantiago/hickory/master/src/cljc,https://raw.githubusercontent.com/davidsantiago/hickory/master/src/cljs">(ns my.html
                                                                  (:require [hickory.core :refer [parse as-hiccup as-hickory]]
                                                                            [hickory.render :refer [hickory-to-html hiccup-to-html]]
                                                                            [hickory.convert :refer [hiccup-to-hickory]]))
                                                                </div></div><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Hickory</span> <span class="project-version">0.7.1-SNAPSHOT</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>hickory</span></div></div></li><li class="depth-2 branch"><a href="hickory.convert.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>convert</span></div></a></li><li class="depth-2 branch"><a href="hickory.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="hickory.hiccup-utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>hiccup-utils</span></div></a></li><li class="depth-2 branch"><a href="hickory.render.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>render</span></div></a></li><li class="depth-2 branch current"><a href="hickory.select.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>select</span></div></a></li><li class="depth-2 branch"><a href="hickory.utils.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>utils</span></div></a></li><li class="depth-2"><a href="hickory.zip.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>zip</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="hickory.select.html#var-after-subtree"><div class="inner"><span>after-subtree</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-after-subtree"><div class="inner"><span>after-subtree</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-and"><div class="inner"><span>and</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-and"><div class="inner"><span>and</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-any"><div class="inner"><span>any</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-any"><div class="inner"><span>any</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-attr"><div class="inner"><span>attr</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-attr"><div class="inner"><span>attr</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-child"><div class="inner"><span>child</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-child"><div class="inner"><span>child</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-class"><div class="inner"><span>class</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-class"><div class="inner"><span>class</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-count-until"><div class="inner"><span>count-until</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-count-until"><div class="inner"><span>count-until</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-descendant"><div class="inner"><span>descendant</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-descendant"><div class="inner"><span>descendant</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-el-not"><div class="inner"><span>el-not</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-el-not"><div class="inner"><span>el-not</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-element"><div class="inner"><span>element</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-element"><div class="inner"><span>element</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-element-child"><div class="inner"><span>element-child</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-element-child"><div class="inner"><span>element-child</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-find-in-text"><div class="inner"><span>find-in-text</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-find-in-text"><div class="inner"><span>find-in-text</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-first-child"><div class="inner"><span>first-child</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-first-child"><div class="inner"><span>first-child</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-follow"><div class="inner"><span>follow</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-follow"><div class="inner"><span>follow</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-follow-adjacent"><div class="inner"><span>follow-adjacent</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-follow-adjacent"><div class="inner"><span>follow-adjacent</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-has-child"><div class="inner"><span>has-child</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-has-child"><div class="inner"><span>has-child</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-has-descendant"><div class="inner"><span>has-descendant</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-has-descendant"><div class="inner"><span>has-descendant</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-id"><div class="inner"><span>id</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-id"><div class="inner"><span>id</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-last-child"><div class="inner"><span>last-child</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-last-child"><div class="inner"><span>last-child</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-left-of-node-type"><div class="inner"><span>left-of-node-type</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-left-of-node-type"><div class="inner"><span>left-of-node-type</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-left-pred"><div class="inner"><span>left-pred</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-left-pred"><div class="inner"><span>left-pred</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-n-moves-until"><div class="inner"><span>n-moves-until</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-n-moves-until"><div class="inner"><span>n-moves-until</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-next-of-node-type"><div class="inner"><span>next-of-node-type</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-next-of-node-type"><div class="inner"><span>next-of-node-type</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-next-pred"><div class="inner"><span>next-pred</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-next-pred"><div class="inner"><span>next-pred</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-node-type"><div class="inner"><span>node-type</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-node-type"><div class="inner"><span>node-type</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-not"><div class="inner"><span>not</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-not"><div class="inner"><span>not</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-nth-child"><div class="inner"><span>nth-child</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-nth-child"><div class="inner"><span>nth-child</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-nth-last-child"><div class="inner"><span>nth-last-child</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-nth-last-child"><div class="inner"><span>nth-last-child</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-nth-last-of-type"><div class="inner"><span>nth-last-of-type</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-nth-last-of-type"><div class="inner"><span>nth-last-of-type</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-nth-of-type"><div class="inner"><span>nth-of-type</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-nth-of-type"><div class="inner"><span>nth-of-type</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-or"><div class="inner"><span>or</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-or"><div class="inner"><span>or</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-ordered"><div class="inner"><span>ordered</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-ordered"><div class="inner"><span>ordered</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-ordered-adjacent"><div class="inner"><span>ordered-adjacent</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-ordered-adjacent"><div class="inner"><span>ordered-adjacent</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-precede"><div class="inner"><span>precede</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-precede"><div class="inner"><span>precede</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-precede-adjacent"><div class="inner"><span>precede-adjacent</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-precede-adjacent"><div class="inner"><span>precede-adjacent</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-prev-of-node-type"><div class="inner"><span>prev-of-node-type</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-prev-of-node-type"><div class="inner"><span>prev-of-node-type</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-prev-pred"><div class="inner"><span>prev-pred</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-prev-pred"><div class="inner"><span>prev-pred</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-right-of-node-type"><div class="inner"><span>right-of-node-type</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-right-of-node-type"><div class="inner"><span>right-of-node-type</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-right-pred"><div class="inner"><span>right-pred</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-right-pred"><div class="inner"><span>right-pred</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-root"><div class="inner"><span>root</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-root"><div class="inner"><span>root</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-select"><div class="inner"><span>select</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-select"><div class="inner"><span>select</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-select-locs"><div class="inner"><span>select-locs</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-select-locs"><div class="inner"><span>select-locs</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-select-next-loc"><div class="inner"><span>select-next-loc</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-select-next-loc"><div class="inner"><span>select-next-loc</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-tag"><div class="inner"><span>tag</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-tag"><div class="inner"><span>tag</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-until"><div class="inner"><span>until</span></div></a></li><li class="depth-1"><a href="hickory.select.html#var-until"><div class="inner"><span>until</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">hickory.select</h1><div class="doc"><div class="markdown"><p>Functions to query hickory-format HTML data.</p>
<p>See clojure.zip for more information on zippers, locs, nodes, next, etc.</p></div></div><div class="public anchor" id="var-after-subtree"><h3>after-subtree</h3><div class="usage"><code>(after-subtree zip-loc)</code></div><div class="doc"><div class="markdown"><p>Given a zipper loc, returns the zipper loc that is the first one after the arg’s subtree, if there is a subtree. If there is no loc after this loc’s subtree, returns the end node.</p></div></div></div><div class="public anchor" id="var-after-subtree"><h3>after-subtree</h3><div class="usage"><code>(after-subtree zip-loc)</code></div><div class="doc"><div class="markdown"><p>Given a zipper loc, returns the zipper loc that is the first one after the arg’s subtree, if there is a subtree. If there is no loc after this loc’s subtree, returns the end node.</p></div></div></div><div class="public anchor" id="var-and"><h3>and</h3><div class="usage"><code>(and &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes any number of selectors and returns a selector that is true if all of the argument selectors are true.</p></div></div></div><div class="public anchor" id="var-and"><h3>and</h3><div class="usage"><code>(and &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes any number of selectors and returns a selector that is true if all of the argument selectors are true.</p></div></div></div><div class="public anchor" id="var-any"><h3>any</h3><div class="usage"><code>(any hzip-loc)</code></div><div class="doc"><div class="markdown"><p>This selector takes no args, it simply is the selector function. It returns true on any element it is called on; corresponds to the CSS ’*’ selector.</p></div></div></div><div class="public anchor" id="var-any"><h3>any</h3><div class="usage"><code>(any hzip-loc)</code></div><div class="doc"><div class="markdown"><p>This selector takes no args, it simply is the selector function. It returns true on any element it is called on; corresponds to the CSS ’*’ selector.</p></div></div></div><div class="public anchor" id="var-attr"><h3>attr</h3><div class="usage"><code>(attr attr-name)</code><code>(attr attr-name predicate)</code></div><div class="doc"><div class="markdown"><p>Returns a function that takes a zip-loc argument and returns the zip-loc passed in iff it has the given attribute, and that attribute optionally satisfies a predicate given as an additional argument. With a single argument, the attribute name (a string, keyword, or symbol), the function returned will return the zip-loc if that attribute is present (and has any value) on the zip-loc’s node. The attribute name will be compared case-insensitively, but the attribute value (if present), will be passed as-is to the predicate.</p>
<p>If the predicate argument is given, it will only return the zip-loc if that predicate is satisfied when given the attribute’s value as its only argument. Note that the predicate only gets called when the attribute is present, so it can assume its argument is not nil.</p></div></div></div><div class="public anchor" id="var-attr"><h3>attr</h3><div class="usage"><code>(attr attr-name)</code><code>(attr attr-name predicate)</code></div><div class="doc"><div class="markdown"><p>Returns a function that takes a zip-loc argument and returns the zip-loc passed in iff it has the given attribute, and that attribute optionally satisfies a predicate given as an additional argument. With a single argument, the attribute name (a string, keyword, or symbol), the function returned will return the zip-loc if that attribute is present (and has any value) on the zip-loc’s node. The attribute name will be compared case-insensitively, but the attribute value (if present), will be passed as-is to the predicate.</p>
<p>If the predicate argument is given, it will only return the zip-loc if that predicate is satisfied when given the attribute’s value as its only argument. Note that the predicate only gets called when the attribute is present, so it can assume its argument is not nil.</p></div></div></div><div class="public anchor" id="var-child"><h3>child</h3><div class="usage"><code>(child &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes any number of selectors as arguments and returns a selector that returns true when the zip-loc given as the argument is at the end of a chain of direct child relationships specified by the selectors given as arguments.</p>
<p>Example: (child (tag :div) (class :foo) (attr :disabled))  will select the input in </p><div><span class="foo"><input disabled="" /></span></div>  but not in <div><span class="foo"><b><input disabled="" /></b></span></div><p></p></div></div></div><div class="public anchor" id="var-child"><h3>child</h3><div class="usage"><code>(child &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes any number of selectors as arguments and returns a selector that returns true when the zip-loc given as the argument is at the end of a chain of direct child relationships specified by the selectors given as arguments.</p>
<p>Example: (child (tag :div) (class :foo) (attr :disabled))  will select the input in </p><div><span class="foo"><input disabled="" /></span></div>  but not in <div><span class="foo"><b><input disabled="" /></b></span></div><p></p></div></div></div><div class="public anchor" id="var-class"><h3>class</h3><div class="usage"><code>(class class-name)</code></div><div class="doc"><div class="markdown"><p>Returns a function that takes a zip-loc argument and returns the zip-loc passed in iff it has the given class. The class argument can be a String or Named (keyword, symbol). The class name comparison is done case-insensitively.</p></div></div></div><div class="public anchor" id="var-class"><h3>class</h3><div class="usage"><code>(class class-name)</code></div><div class="doc"><div class="markdown"><p>Returns a function that takes a zip-loc argument and returns the zip-loc passed in iff it has the given class. The class argument can be a String or Named (keyword, symbol). The class name comparison is done case-insensitively.</p></div></div></div><div class="public anchor" id="var-count-until"><h3>count-until</h3><div class="usage"><code>(count-until f val pred)</code></div><div class="doc"><div class="markdown"><p>Calls f on val until pred called on the result is true. If not, it repeats by calling f on the result, etc. The count of times this process was repeated until pred returned true is returned.</p></div></div></div><div class="public anchor" id="var-count-until"><h3>count-until</h3><div class="usage"><code>(count-until f val pred)</code></div><div class="doc"><div class="markdown"><p>Calls f on val until pred called on the result is true. If not, it repeats by calling f on the result, etc. The count of times this process was repeated until pred returned true is returned.</p></div></div></div><div class="public anchor" id="var-descendant"><h3>descendant</h3><div class="usage"><code>(descendant &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes any number of selectors as arguments and returns a selector that returns true when the zip-loc given as the argument is at the end of a chain of descendant relationships specified by the selectors given as arguments. To be clear, the node selected matches the final selector, but the previous selectors can match anywhere in the node’s ancestry, provided they match in the order they are given as arguments, from top to bottom.</p>
<p>Example: (descendant (tag :div) (class :foo) (attr :disabled))  will select the input in both </p><div><span class="foo"><input disabled="" /></span></div>  and <div><span class="foo"><b><input disabled="" /></b></span></div><p></p></div></div></div><div class="public anchor" id="var-descendant"><h3>descendant</h3><div class="usage"><code>(descendant &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes any number of selectors as arguments and returns a selector that returns true when the zip-loc given as the argument is at the end of a chain of descendant relationships specified by the selectors given as arguments. To be clear, the node selected matches the final selector, but the previous selectors can match anywhere in the node’s ancestry, provided they match in the order they are given as arguments, from top to bottom.</p>
<p>Example: (descendant (tag :div) (class :foo) (attr :disabled))  will select the input in both </p><div><span class="foo"><input disabled="" /></span></div>  and <div><span class="foo"><b><input disabled="" /></b></span></div><p></p></div></div></div><div class="public anchor" id="var-el-not"><h3>el-not</h3><div class="usage"><code>(el-not selector)</code></div><div class="doc"><div class="markdown"><p>Takes a selector argument and returns a selector that is true if the underlying selector is false on its argument and vice versa, and additionally that argument is an element node. Compared to the ‘not’ selector, this corresponds more closely to the CSS equivalent, which will only ever select elements.</p></div></div></div><div class="public anchor" id="var-el-not"><h3>el-not</h3><div class="usage"><code>(el-not selector)</code></div><div class="doc"><div class="markdown"><p>Takes a selector argument and returns a selector that is true if the underlying selector is false on its argument and vice versa, and additionally that argument is an element node. Compared to the ‘not’ selector, this corresponds more closely to the CSS equivalent, which will only ever select elements.</p></div></div></div><div class="public anchor" id="var-element"><h3>element</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Another name for the any selector, to express that it can be used to only select elements.</p></div></div></div><div class="public anchor" id="var-element"><h3>element</h3><div class="usage"></div><div class="doc"><div class="markdown"><p>Another name for the any selector, to express that it can be used to only select elements.</p></div></div></div><div class="public anchor" id="var-element-child"><h3>element-child</h3><div class="usage"><code>(element-child hzip-loc)</code></div><div class="doc"><div class="markdown"><p>This selector takes no args, it simply is the selector function. It returns the zip-loc passed in iff that loc is an element, and it has a parent that is also an element.</p></div></div></div><div class="public anchor" id="var-element-child"><h3>element-child</h3><div class="usage"><code>(element-child hzip-loc)</code></div><div class="doc"><div class="markdown"><p>This selector takes no args, it simply is the selector function. It returns the zip-loc passed in iff that loc is an element, and it has a parent that is also an element.</p></div></div></div><div class="public anchor" id="var-find-in-text"><h3>find-in-text</h3><div class="usage"><code>(find-in-text re)</code></div><div class="doc"><div class="markdown"><p>Returns a function that takes a zip-loc argument and returns the zip-loc passed in iff it has some text node in its contents that matches the regular expression. Note that this only applies to the direct text content of a node; nodes which have the given text in one of their child nodes will not be selected.</p></div></div></div><div class="public anchor" id="var-find-in-text"><h3>find-in-text</h3><div class="usage"><code>(find-in-text re)</code></div><div class="doc"><div class="markdown"><p>Returns a function that takes a zip-loc argument and returns the zip-loc passed in iff it has some text node in its contents that matches the regular expression. Note that this only applies to the direct text content of a node; nodes which have the given text in one of their child nodes will not be selected.</p></div></div></div><div class="public anchor" id="var-first-child"><h3>first-child</h3><div class="usage"><code>(first-child hzip-loc)</code></div><div class="doc"><div class="markdown"><p>This selector takes no args, it is simply the selector. Returns true if the node is the first child of its parent (and it has a parent).</p></div></div></div><div class="public anchor" id="var-first-child"><h3>first-child</h3><div class="usage"><code>(first-child hzip-loc)</code></div><div class="doc"><div class="markdown"><p>This selector takes no args, it is simply the selector. Returns true if the node is the first child of its parent (and it has a parent).</p></div></div></div><div class="public anchor" id="var-follow"><h3>follow</h3><div class="usage"><code>(follow &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes any number of selectors as arguments and returns a selector that returns true when the zip-loc given as the argument is at the end of a chain of element sibling relationships specified by the selectors given as arguments; intervening elements that do not satisfy a selector are simply ignored and do not prevent a match.</p>
<p>Example: (follow (tag :div) (class :foo))  will select the span in both </p><div>…</div><span class="foo">…</span>  and <div>…</div><b>…</b><span class="foo">…</span><p></p></div></div></div><div class="public anchor" id="var-follow"><h3>follow</h3><div class="usage"><code>(follow &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes any number of selectors as arguments and returns a selector that returns true when the zip-loc given as the argument is at the end of a chain of element sibling relationships specified by the selectors given as arguments; intervening elements that do not satisfy a selector are simply ignored and do not prevent a match.</p>
<p>Example: (follow (tag :div) (class :foo))  will select the span in both </p><div>…</div><span class="foo">…</span>  and <div>…</div><b>…</b><span class="foo">…</span><p></p></div></div></div><div class="public anchor" id="var-follow-adjacent"><h3>follow-adjacent</h3><div class="usage"><code>(follow-adjacent &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes any number of selectors as arguments and returns a selector that returns true when the zip-loc given as the argument is at the end of a chain of direct element sibling relationships specified by the selectors given as arguments.</p>
<p>Example: (follow-adjacent (tag :div) (class :foo))  will select the span in </p><div>…</div><span class="foo">…</span>  but not in <div>…</div><b>…</b><span class="foo">…</span><p></p></div></div></div><div class="public anchor" id="var-follow-adjacent"><h3>follow-adjacent</h3><div class="usage"><code>(follow-adjacent &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes any number of selectors as arguments and returns a selector that returns true when the zip-loc given as the argument is at the end of a chain of direct element sibling relationships specified by the selectors given as arguments.</p>
<p>Example: (follow-adjacent (tag :div) (class :foo))  will select the span in </p><div>…</div><span class="foo">…</span>  but not in <div>…</div><b>…</b><span class="foo">…</span><p></p></div></div></div><div class="public anchor" id="var-has-child"><h3>has-child</h3><div class="usage"><code>(has-child selector)</code></div><div class="doc"><div class="markdown"><p>Takes a selector as argument and returns a selector that returns true when some direct child node of the zip-loc given as the argument satisfies the selector.</p>
<p>Example: (has-child (tag :div))  will select only the inner span in </p><div><span><div></div></span></div><p></p></div></div></div><div class="public anchor" id="var-has-child"><h3>has-child</h3><div class="usage"><code>(has-child selector)</code></div><div class="doc"><div class="markdown"><p>Takes a selector as argument and returns a selector that returns true when some direct child node of the zip-loc given as the argument satisfies the selector.</p>
<p>Example: (has-child (tag :div))  will select only the inner span in </p><div><span><div></div></span></div><p></p></div></div></div><div class="public anchor" id="var-has-descendant"><h3>has-descendant</h3><div class="usage"><code>(has-descendant selector)</code></div><div class="doc"><div class="markdown"><p>Takes a selector as argument and returns a selector that returns true when some descendant node of the zip-loc given as the argument satisfies the selector.</p>
<p>Be aware that because this selector must do a full sub-tree search on each node examined, it can have terrible performance. It’s helpful if this is a late clause in an <code>and</code>, to prevent it from even attempting to match unless other criteria have been met first.</p>
<p>Example: (has-descendant (tag :div))  will select the span and the outer div, but not the inner div, in <span></span></p><div><div></div></div><p></p></div></div></div><div class="public anchor" id="var-has-descendant"><h3>has-descendant</h3><div class="usage"><code>(has-descendant selector)</code></div><div class="doc"><div class="markdown"><p>Takes a selector as argument and returns a selector that returns true when some descendant node of the zip-loc given as the argument satisfies the selector.</p>
<p>Be aware that because this selector must do a full sub-tree search on each node examined, it can have terrible performance. It’s helpful if this is a late clause in an <code>and</code>, to prevent it from even attempting to match unless other criteria have been met first.</p>
<p>Example: (has-descendant (tag :div))  will select the span and the outer div, but not the inner div, in <span></span></p><div><div></div></div><p></p></div></div></div><div class="public anchor" id="var-id"><h3>id</h3><div class="usage"><code>(id id)</code></div><div class="doc"><div class="markdown"><p>Returns a function that takes a zip-loc argument and returns the zip-loc passed in iff it has the given id. The id argument can be a String or Named (keyword, symbol). The id name comparison is done case-insensitively.</p></div></div></div><div class="public anchor" id="var-id"><h3>id</h3><div class="usage"><code>(id id)</code></div><div class="doc"><div class="markdown"><p>Returns a function that takes a zip-loc argument and returns the zip-loc passed in iff it has the given id. The id argument can be a String or Named (keyword, symbol). The id name comparison is done case-insensitively.</p></div></div></div><div class="public anchor" id="var-last-child"><h3>last-child</h3><div class="usage"><code>(last-child hzip-loc)</code></div><div class="doc"><div class="markdown"><p>This selector takes no args, it is simply the selector. Returns true if the node is the last child of its parent (and it has a parent.</p></div></div></div><div class="public anchor" id="var-last-child"><h3>last-child</h3><div class="usage"><code>(last-child hzip-loc)</code></div><div class="doc"><div class="markdown"><p>This selector takes no args, it is simply the selector. Returns true if the node is the last child of its parent (and it has a parent.</p></div></div></div><div class="public anchor" id="var-left-of-node-type"><h3>left-of-node-type</h3><div class="usage"><code>(left-of-node-type hzip-loc node-type)</code></div><div class="doc"><div class="markdown"><p>Like clojure.zip/left, but only counts moves to nodes that have the given type.</p></div></div></div><div class="public anchor" id="var-left-of-node-type"><h3>left-of-node-type</h3><div class="usage"><code>(left-of-node-type hzip-loc node-type)</code></div><div class="doc"><div class="markdown"><p>Like clojure.zip/left, but only counts moves to nodes that have the given type.</p></div></div></div><div class="public anchor" id="var-left-pred"><h3>left-pred</h3><div class="usage"><code>(left-pred hzip-loc pred)</code></div><div class="doc"><div class="markdown"><p>Like clojure.zip/left, but moves until it reaches a node that returns true when the function in the pred argument is called on them, or reaches the left boundary of the current group of siblings.</p></div></div></div><div class="public anchor" id="var-left-pred"><h3>left-pred</h3><div class="usage"><code>(left-pred hzip-loc pred)</code></div><div class="doc"><div class="markdown"><p>Like clojure.zip/left, but moves until it reaches a node that returns true when the function in the pred argument is called on them, or reaches the left boundary of the current group of siblings.</p></div></div></div><div class="public anchor" id="var-n-moves-until"><h3>n-moves-until</h3><div class="usage"><code>(n-moves-until n c move term-pred)</code></div><div class="doc"><div class="markdown"><p>This selector returns a selector function that selects its argument if that argument is some “distance” from a “boundary.” This is an abstract way of phrasing it, but it captures the full generality.</p>
<p>The selector this function returns will apply the move argument to its own output, beginning with its zipper loc argument, until the term-pred argument called on its output returns true. At that point, the number of times the move function was called successfully is compared to kn+c; if there exists some value of k such that the two quantities are equal, then the selector will return the argument zipper loc successfully.</p>
<p>For example, (n-moves-until 2 1 clojure.zip/left nil?) will return a selector that calls zip/left on its own output, beginning with the argument zipper loc, until its return value is nil (nil? returns true). Suppose it called left 5 times before zip/left returned nil. Then the selector will return with success, since 2k+1 = 5 for k = 2.</p>
<p>Most nth-child-* selectors in this package use n-moves-until in their implementation.</p></div></div></div><div class="public anchor" id="var-n-moves-until"><h3>n-moves-until</h3><div class="usage"><code>(n-moves-until n c move term-pred)</code></div><div class="doc"><div class="markdown"><p>This selector returns a selector function that selects its argument if that argument is some “distance” from a “boundary.” This is an abstract way of phrasing it, but it captures the full generality.</p>
<p>The selector this function returns will apply the move argument to its own output, beginning with its zipper loc argument, until the term-pred argument called on its output returns true. At that point, the number of times the move function was called successfully is compared to kn+c; if there exists some value of k such that the two quantities are equal, then the selector will return the argument zipper loc successfully.</p>
<p>For example, (n-moves-until 2 1 clojure.zip/left nil?) will return a selector that calls zip/left on its own output, beginning with the argument zipper loc, until its return value is nil (nil? returns true). Suppose it called left 5 times before zip/left returned nil. Then the selector will return with success, since 2k+1 = 5 for k = 2.</p>
<p>Most nth-child-* selectors in this package use n-moves-until in their implementation.</p></div></div></div><div class="public anchor" id="var-next-of-node-type"><h3>next-of-node-type</h3><div class="usage"><code>(next-of-node-type hzip-loc node-type)</code></div><div class="doc"><div class="markdown"><p>Like clojure.zip/next, but only counts moves to nodes that have the given type.</p></div></div></div><div class="public anchor" id="var-next-of-node-type"><h3>next-of-node-type</h3><div class="usage"><code>(next-of-node-type hzip-loc node-type)</code></div><div class="doc"><div class="markdown"><p>Like clojure.zip/next, but only counts moves to nodes that have the given type.</p></div></div></div><div class="public anchor" id="var-next-pred"><h3>next-pred</h3><div class="usage"><code>(next-pred hzip-loc pred)</code></div><div class="doc"><div class="markdown"><p>Like clojure.zip/next, but moves until it reaches a node that returns true when the function in the pred argument is called on them, or reaches the end.</p></div></div></div><div class="public anchor" id="var-next-pred"><h3>next-pred</h3><div class="usage"><code>(next-pred hzip-loc pred)</code></div><div class="doc"><div class="markdown"><p>Like clojure.zip/next, but moves until it reaches a node that returns true when the function in the pred argument is called on them, or reaches the end.</p></div></div></div><div class="public anchor" id="var-node-type"><h3>node-type</h3><div class="usage"><code>(node-type type)</code></div><div class="doc"><div class="markdown"><p>Return a function that takes a zip-loc argument and returns the zip-loc passed in iff it has the given node type. The type argument can be a String or Named (keyword, symbol). The node type comparison is done case-insensitively.</p></div></div></div><div class="public anchor" id="var-node-type"><h3>node-type</h3><div class="usage"><code>(node-type type)</code></div><div class="doc"><div class="markdown"><p>Return a function that takes a zip-loc argument and returns the zip-loc passed in iff it has the given node type. The type argument can be a String or Named (keyword, symbol). The node type comparison is done case-insensitively.</p></div></div></div><div class="public anchor" id="var-not"><h3>not</h3><div class="usage"><code>(not selector)</code></div><div class="doc"><div class="markdown"><p>Takes a selector argument and returns a selector that is true if the underlying selector is false on its argument, and vice versa.</p></div></div></div><div class="public anchor" id="var-not"><h3>not</h3><div class="usage"><code>(not selector)</code></div><div class="doc"><div class="markdown"><p>Takes a selector argument and returns a selector that is true if the underlying selector is false on its argument, and vice versa.</p></div></div></div><div class="public anchor" id="var-nth-child"><h3>nth-child</h3><div class="usage"><code>(nth-child c)</code><code>(nth-child n c)</code></div><div class="doc"><div class="markdown"><p>Returns a function that returns true if the node is the nth child of its parent (and it has a parent). First element is 1, last is n.</p></div></div></div><div class="public anchor" id="var-nth-child"><h3>nth-child</h3><div class="usage"><code>(nth-child c)</code><code>(nth-child n c)</code></div><div class="doc"><div class="markdown"><p>Returns a function that returns true if the node is the nth child of its parent (and it has a parent). First element is 1, last is n.</p></div></div></div><div class="public anchor" id="var-nth-last-child"><h3>nth-last-child</h3><div class="usage"><code>(nth-last-child c)</code><code>(nth-last-child n c)</code></div><div class="doc"><div class="markdown"><p>Returns a function that returns true if the node has n siblings after it, and has a parent.</p></div></div></div><div class="public anchor" id="var-nth-last-child"><h3>nth-last-child</h3><div class="usage"><code>(nth-last-child c)</code><code>(nth-last-child n c)</code></div><div class="doc"><div class="markdown"><p>Returns a function that returns true if the node has n siblings after it, and has a parent.</p></div></div></div><div class="public anchor" id="var-nth-last-of-type"><h3>nth-last-of-type</h3><div class="usage"><code>(nth-last-of-type c typ)</code><code>(nth-last-of-type n c typ)</code></div><div class="doc"><div class="markdown"><p>Returns a function that returns true if the node is the nth last child of its parent (and it has a parent) of the given tag type. First element is 1, last is n.</p></div></div></div><div class="public anchor" id="var-nth-last-of-type"><h3>nth-last-of-type</h3><div class="usage"><code>(nth-last-of-type c typ)</code><code>(nth-last-of-type n c typ)</code></div><div class="doc"><div class="markdown"><p>Returns a function that returns true if the node is the nth last child of its parent (and it has a parent) of the given tag type. First element is 1, last is n.</p></div></div></div><div class="public anchor" id="var-nth-of-type"><h3>nth-of-type</h3><div class="usage"><code>(nth-of-type c typ)</code><code>(nth-of-type n c typ)</code></div><div class="doc"><div class="markdown"><p>Returns a function that returns true if the node is the nth child of its parent (and it has a parent) of the given tag type. First element is 1, last is n.</p></div></div></div><div class="public anchor" id="var-nth-of-type"><h3>nth-of-type</h3><div class="usage"><code>(nth-of-type c typ)</code><code>(nth-of-type n c typ)</code></div><div class="doc"><div class="markdown"><p>Returns a function that returns true if the node is the nth child of its parent (and it has a parent) of the given tag type. First element is 1, last is n.</p></div></div></div><div class="public anchor" id="var-or"><h3>or</h3><div class="usage"><code>(or &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes any number of selectors and returns a selector that is true if any of the argument selectors are true.</p></div></div></div><div class="public anchor" id="var-or"><h3>or</h3><div class="usage"><code>(or &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes any number of selectors and returns a selector that is true if any of the argument selectors are true.</p></div></div></div><div class="public anchor" id="var-ordered"><h3>ordered</h3><div class="usage"><code>(ordered move-fn &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes a zipper movement function and any number of selectors as arguments and returns a selector that returns true when the zip-loc given as the argument is satisfied by the first selector, and some zip-loc arrived at by applying the move-fn argument <em>one or more times</em> is satisfied by the second selector, and so on for all the selectors given as arguments. If the move-fn moves to nil before a the full selector list is satisfied, the entire selector fails, but note that success is checked before a move to nil is checked, so satisfying the last selector with the last node you can move to succeeds.</p></div></div></div><div class="public anchor" id="var-ordered"><h3>ordered</h3><div class="usage"><code>(ordered move-fn &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes a zipper movement function and any number of selectors as arguments and returns a selector that returns true when the zip-loc given as the argument is satisfied by the first selector, and some zip-loc arrived at by applying the move-fn argument <em>one or more times</em> is satisfied by the second selector, and so on for all the selectors given as arguments. If the move-fn moves to nil before a the full selector list is satisfied, the entire selector fails, but note that success is checked before a move to nil is checked, so satisfying the last selector with the last node you can move to succeeds.</p></div></div></div><div class="public anchor" id="var-ordered-adjacent"><h3>ordered-adjacent</h3><div class="usage"><code>(ordered-adjacent move-fn &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes a zipper movement function and any number of selectors as arguments and returns a selector that returns true when the zip-loc given as the argument is satisfied by the first selector, and the zip-loc arrived at by applying the move-fn argument is satisfied by the second selector, and so on for all the selectors given as arguments. If the move-fn moves to nil before the full selector list is satisfied, the entire selector fails, but note that success is checked before a move to nil is checked, so satisfying the last selector with the last node you can move to succeeds.</p></div></div></div><div class="public anchor" id="var-ordered-adjacent"><h3>ordered-adjacent</h3><div class="usage"><code>(ordered-adjacent move-fn &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes a zipper movement function and any number of selectors as arguments and returns a selector that returns true when the zip-loc given as the argument is satisfied by the first selector, and the zip-loc arrived at by applying the move-fn argument is satisfied by the second selector, and so on for all the selectors given as arguments. If the move-fn moves to nil before the full selector list is satisfied, the entire selector fails, but note that success is checked before a move to nil is checked, so satisfying the last selector with the last node you can move to succeeds.</p></div></div></div><div class="public anchor" id="var-precede"><h3>precede</h3><div class="usage"><code>(precede &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes any number of selectors as arguments and returns a selector that returns true when the zip-loc given as the argument is at the beginning of a chain of element sibling relationships specified by the selectors given as arguments; intervening elements that do not satisfy a selector are simply ignored and do not prevent a match.</p>
<p>Example: (precede (tag :div) (class :foo))  will select the div in both </p><div>…</div><span class="foo">…</span>  and <div>…</div><b>…</b><span class="foo">…</span><p></p></div></div></div><div class="public anchor" id="var-precede"><h3>precede</h3><div class="usage"><code>(precede &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes any number of selectors as arguments and returns a selector that returns true when the zip-loc given as the argument is at the beginning of a chain of element sibling relationships specified by the selectors given as arguments; intervening elements that do not satisfy a selector are simply ignored and do not prevent a match.</p>
<p>Example: (precede (tag :div) (class :foo))  will select the div in both </p><div>…</div><span class="foo">…</span>  and <div>…</div><b>…</b><span class="foo">…</span><p></p></div></div></div><div class="public anchor" id="var-precede-adjacent"><h3>precede-adjacent</h3><div class="usage"><code>(precede-adjacent &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes any number of selectors as arguments and returns a selector that returns true when the zip-loc given as the argument is at the beginning of a chain of direct element sibling relationships specified by the selectors given as arguments.</p>
<p>Example: (precede-adjacent (tag :div) (class :foo))  will select the div in </p><div>…</div><span class="foo">…</span>  but not in <div>…</div><b>…</b><span class="foo">…</span><p></p></div></div></div><div class="public anchor" id="var-precede-adjacent"><h3>precede-adjacent</h3><div class="usage"><code>(precede-adjacent &amp; selectors)</code></div><div class="doc"><div class="markdown"><p>Takes any number of selectors as arguments and returns a selector that returns true when the zip-loc given as the argument is at the beginning of a chain of direct element sibling relationships specified by the selectors given as arguments.</p>
<p>Example: (precede-adjacent (tag :div) (class :foo))  will select the div in </p><div>…</div><span class="foo">…</span>  but not in <div>…</div><b>…</b><span class="foo">…</span><p></p></div></div></div><div class="public anchor" id="var-prev-of-node-type"><h3>prev-of-node-type</h3><div class="usage"><code>(prev-of-node-type hzip-loc node-type)</code></div><div class="doc"><div class="markdown"><p>Like clojure.zip/prev, but only counts moves to nodes that have the given type.</p></div></div></div><div class="public anchor" id="var-prev-of-node-type"><h3>prev-of-node-type</h3><div class="usage"><code>(prev-of-node-type hzip-loc node-type)</code></div><div class="doc"><div class="markdown"><p>Like clojure.zip/prev, but only counts moves to nodes that have the given type.</p></div></div></div><div class="public anchor" id="var-prev-pred"><h3>prev-pred</h3><div class="usage"><code>(prev-pred hzip-loc pred)</code></div><div class="doc"><div class="markdown"><p>Like clojure.zip/prev, but moves until it reaches a node that returns true when the function in the pred argument is called on them, or reaches the beginning.</p></div></div></div><div class="public anchor" id="var-prev-pred"><h3>prev-pred</h3><div class="usage"><code>(prev-pred hzip-loc pred)</code></div><div class="doc"><div class="markdown"><p>Like clojure.zip/prev, but moves until it reaches a node that returns true when the function in the pred argument is called on them, or reaches the beginning.</p></div></div></div><div class="public anchor" id="var-right-of-node-type"><h3>right-of-node-type</h3><div class="usage"><code>(right-of-node-type hzip-loc node-type)</code></div><div class="doc"><div class="markdown"><p>Like clojure.zip/right, but only counts moves to nodes that have the given type.</p></div></div></div><div class="public anchor" id="var-right-of-node-type"><h3>right-of-node-type</h3><div class="usage"><code>(right-of-node-type hzip-loc node-type)</code></div><div class="doc"><div class="markdown"><p>Like clojure.zip/right, but only counts moves to nodes that have the given type.</p></div></div></div><div class="public anchor" id="var-right-pred"><h3>right-pred</h3><div class="usage"><code>(right-pred hzip-loc pred)</code></div><div class="doc"><div class="markdown"><p>Like clojure.zip/right, but moves until it reaches a node that returns true when the function in the pred argument is called on them, or reaches the right boundary of the current group of siblings.</p></div></div></div><div class="public anchor" id="var-right-pred"><h3>right-pred</h3><div class="usage"><code>(right-pred hzip-loc pred)</code></div><div class="doc"><div class="markdown"><p>Like clojure.zip/right, but moves until it reaches a node that returns true when the function in the pred argument is called on them, or reaches the right boundary of the current group of siblings.</p></div></div></div><div class="public anchor" id="var-root"><h3>root</h3><div class="usage"><code>(root hzip-loc)</code></div><div class="doc"><div class="markdown"><p>This selector takes no args, it simply is the selector function. It returns the zip-loc of the root node (the HTML element).</p></div></div></div><div class="public anchor" id="var-root"><h3>root</h3><div class="usage"><code>(root hzip-loc)</code></div><div class="doc"><div class="markdown"><p>This selector takes no args, it simply is the selector function. It returns the zip-loc of the root node (the HTML element).</p></div></div></div><div class="public anchor" id="var-select"><h3>select</h3><div class="usage"><code>(select selector-fn hickory-tree)</code></div><div class="doc"><div class="markdown"><p>Given a selector function and a hickory data structure, returns a vector containing all of the hickory nodes selected by the selector function.</p></div></div></div><div class="public anchor" id="var-select"><h3>select</h3><div class="usage"><code>(select selector-fn hickory-tree)</code></div><div class="doc"><div class="markdown"><p>Given a selector function and a hickory data structure, returns a vector containing all of the hickory nodes selected by the selector function.</p></div></div></div><div class="public anchor" id="var-select-locs"><h3>select-locs</h3><div class="usage"><code>(select-locs selector-fn hickory-tree)</code></div><div class="doc"><div class="markdown"><p>Given a selector function and a hickory data structure, returns a vector containing all of the zipper locs selected by the selector function.</p></div></div></div><div class="public anchor" id="var-select-locs"><h3>select-locs</h3><div class="usage"><code>(select-locs selector-fn hickory-tree)</code></div><div class="doc"><div class="markdown"><p>Given a selector function and a hickory data structure, returns a vector containing all of the zipper locs selected by the selector function.</p></div></div></div><div class="public anchor" id="var-select-next-loc"><h3>select-next-loc</h3><div class="usage"><code>(select-next-loc selector-fn hzip-loc)</code><code>(select-next-loc selector-fn hzip-loc next-fn)</code><code>(select-next-loc selector-fn hzip-loc next-fn end?-fn)</code></div><div class="doc"><div class="markdown"><p>Given a selector function and a loc inside a hickory zip data structure, returns the next zipper loc that satisfies the selection function. This can be the loc that is passed in, so be sure to move to the next loc if you want to use this function to exhaustively search through a tree manually. Note that if there is no next node that satisfies the selection function, nil is returned.</p>
<p>The third argument, if present, must be a function of one argument that is called on a zipper loc to return the next loc to consider in the search. By default, this argument is zip/next. The fourth argument, if present, must be a function of one argument that is called on a zipper loc to determine if the end of the search has been reached (true return value). When the fourth argument returns true on a loc, that loc is not considered in the search and the search finishes with a nil return. By default, the fourth argument is zip/end?.</p></div></div></div><div class="public anchor" id="var-select-next-loc"><h3>select-next-loc</h3><div class="usage"><code>(select-next-loc selector-fn hzip-loc)</code><code>(select-next-loc selector-fn hzip-loc next-fn)</code><code>(select-next-loc selector-fn hzip-loc next-fn end?-fn)</code></div><div class="doc"><div class="markdown"><p>Given a selector function and a loc inside a hickory zip data structure, returns the next zipper loc that satisfies the selection function. This can be the loc that is passed in, so be sure to move to the next loc if you want to use this function to exhaustively search through a tree manually. Note that if there is no next node that satisfies the selection function, nil is returned.</p>
<p>The third argument, if present, must be a function of one argument that is called on a zipper loc to return the next loc to consider in the search. By default, this argument is zip/next. The fourth argument, if present, must be a function of one argument that is called on a zipper loc to determine if the end of the search has been reached (true return value). When the fourth argument returns true on a loc, that loc is not considered in the search and the search finishes with a nil return. By default, the fourth argument is zip/end?.</p></div></div></div><div class="public anchor" id="var-tag"><h3>tag</h3><div class="usage"><code>(tag tag)</code></div><div class="doc"><div class="markdown"><p>Return a function that takes a zip-loc argument and returns the zip-loc passed in iff it has the given tag. The tag argument can be a String or Named (keyword, symbol). The tag name comparison is done case-insensitively.</p></div></div></div><div class="public anchor" id="var-tag"><h3>tag</h3><div class="usage"><code>(tag tag)</code></div><div class="doc"><div class="markdown"><p>Return a function that takes a zip-loc argument and returns the zip-loc passed in iff it has the given tag. The tag argument can be a String or Named (keyword, symbol). The tag name comparison is done case-insensitively.</p></div></div></div><div class="public anchor" id="var-until"><h3>until</h3><div class="usage"><code>(until f val pred)</code></div><div class="doc"><div class="markdown"><p>Calls f on val until pred called on the result is true. If not, it repeats by calling f on the result, etc. The value that made pred return true is returned.</p></div></div></div><div class="public anchor" id="var-until"><h3>until</h3><div class="usage"><code>(until f val pred)</code></div><div class="doc"><div class="markdown"><p>Calls f on val until pred called on the result is true. If not, it repeats by calling f on the result, etc. The value that made pred return true is returned.</p></div></div></div></div><script>window.klipse_settings = {
    selector: '.klipse',
    codemirror_options_in: {
    lineWrapping: true,
    autoCloseBrackets: true
    },
    codemirror_options_out: {
    lineWrapping: true
    }
    };</script><script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script></body></html>