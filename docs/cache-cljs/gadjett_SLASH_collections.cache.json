["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "],"~$Object",["^ "],"~$Infinity",["^ "],"~$Function",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$gadjett.collections","~:imports",null,"~:requires",["^ ","~$clojure.set","^>","~$clojure.string","^?","~$zip","~$clojure.zip","^A","^A"],"~:uses",["^ ","~$join","^?","~$split-lines","^?","~$blank?","^?"],"~:defs",["^ ","~$unflatten-keys",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","^;","~:line",429,"~:column",7,"~:end-line",429,"~:end-column",21,"~:arglists",["~#list",["~$quote",["^P",[["~$m"]]]]],"~:doc","\n  Unflattend the keys of a map that has been `flatten-keys`ed.\n\n~~~klipse\n(unflatten-keys {[:a :b] 1, [:c :d] 2, [:c :e] 4, [:c :f :g] 8})\n~~~\n"],"^:","~$gadjett.collections/unflatten-keys","~:variadic",false,"^J","gadjett/collections.cljc","^N",21,"~:method-params",["^P",[["~$m"]]],"~:protocol-impl",null,"~:arglists-meta",["^P",[null,null]],"^L",1,"^K",429,"^M",429,"~:max-fixed-arity",1,"~:fn-var",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","\n  Unflattend the keys of a map that has been `flatten-keys`ed.\n\n~~~klipse\n(unflatten-keys {[:a :b] 1, [:c :d] 2, [:c :e] 4, [:c :f :g] 8})\n~~~\n"],"~$sequence->map",["^ ","^H",null,"^I",["^ ","^J","^;","^K",110,"^L",7,"^M",110,"^N",20,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Converts a sequence into a map where the keys are the indexes of the elements in the sequence.\n\n~~~klipse\n  (sequence->map [10 20 30])\n~~~\n  "],"^:","~$gadjett.collections/sequence->map","^T",false,"^J","gadjett/collections.cljc","^N",20,"^U",["^P",[["~$s"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",110,"^M",110,"^X",1,"^Y",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Converts a sequence into a map where the keys are the indexes of the elements in the sequence.\n\n~~~klipse\n  (sequence->map [10 20 30])\n~~~\n  "],"~$=without-keys?",["^ ","^H",null,"^I",["^ ","^J","^;","^K",9,"^L",7,"^M",9,"^N",21,"^O",["^P",["^Q",["^P",[["~$obj-a","~$obj-b","~$keys-list"]]]]],"^R","Compare two maps exclusing some keys\n\n~~~klipse\n  (=without-keys? {:a 1 :b 2 :c 3} {:a 1 :b 5} #{:b :c})\n~~~\n  "],"^:","~$gadjett.collections/=without-keys?","^T",false,"^J","gadjett/collections.cljc","^N",21,"^U",["^P",[["^11","^12","^13"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",9,"^M",9,"^X",3,"^Y",true,"^O",["^P",["^Q",["^P",[["^11","^12","^13"]]]]],"^R","Compare two maps exclusing some keys\n\n~~~klipse\n  (=without-keys? {:a 1 :b 2 :c 3} {:a 1 :b 5} #{:b :c})\n~~~\n  "],"~$dissoc-in",["^ ","^H",null,"^I",["^ ","^J","^;","^K",284,"^L",7,"^M",284,"^N",16,"^O",["^P",["^Q",["^P",[["~$m",["~$k","~$&","~$ks","~:as","~$keys"]]]]]],"^R","Dissociates an entry from a nested associative structure returning a new nested structure. `keys` is a sequence of keys. Any empty maps that result will not be present in the new structure. See [assoc-in](https://clojuredocs.org/clojure.core/assoc-in)\n\n~~~klipse\n  (dissoc-in {:a 1 :b 2} [:b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2 :B 3} :c 3} [:a :b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2} :c 3} [:a :b])\n~~~\n  "],"^:","~$gadjett.collections/dissoc-in","^T",false,"^J","gadjett/collections.cljc","^N",16,"^U",["^P",[["~$m","~$p__213"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",284,"^M",284,"^X",2,"^Y",true,"^O",["^P",["^Q",["^P",[["~$m",["~$k","~$&","^16","^17","^18"]]]]]],"^R","Dissociates an entry from a nested associative structure returning a new nested structure. `keys` is a sequence of keys. Any empty maps that result will not be present in the new structure. See [assoc-in](https://clojuredocs.org/clojure.core/assoc-in)\n\n~~~klipse\n  (dissoc-in {:a 1 :b 2} [:b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2 :B 3} :c 3} [:a :b])\n~~~\n\n~~~klipse\n  (dissoc-in {:a {:b 2} :c 3} [:a :b])\n~~~\n  "],"~$split-by-predicate-positions",["^ ","^H",null,"^I",["^ ","^J","^;","^K",340,"^L",7,"^M",340,"^N",35,"^O",["^P",["^Q",["^P",[["~$coll","~$pred","~$n","~$d"]]]]],"^R","\n  Optimized version of `split-by-predicate` where we assume that the data is from a signal that we can sample.\n\n  Instead of checking each element, we check 1 over `n` elements.\n\n We return the positions where the data splits.\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.001))]\n    (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 10))\n~~~\n\n  The following assertion holds:\n\n~~~clojure\n  (= (split-by-predicate coll pred n)\n     (map #(apply subsequence data %) (split-by-predicate-positions coll pred n 1)))\n~~~\n\n  Here is an example:\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.01))]\n    (= (split-by-predicate data #(<= -0.01 % 0.01) 2)\n       (map #(apply subsequence data %) (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 1))))\n~~~\n  "],"^:","~$gadjett.collections/split-by-predicate-positions","^T",false,"^J","gadjett/collections.cljc","^N",35,"^U",["^P",[["^1<","^1=","~$n","~$d"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",340,"^M",340,"^X",4,"^Y",true,"^O",["^P",["^Q",["^P",[["^1<","^1=","~$n","~$d"]]]]],"^R","\n  Optimized version of `split-by-predicate` where we assume that the data is from a signal that we can sample.\n\n  Instead of checking each element, we check 1 over `n` elements.\n\n We return the positions where the data splits.\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.001))]\n    (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 10))\n~~~\n\n  The following assertion holds:\n\n~~~clojure\n  (= (split-by-predicate coll pred n)\n     (map #(apply subsequence data %) (split-by-predicate-positions coll pred n 1)))\n~~~\n\n  Here is an example:\n\n~~~klipse\n  (let [data (map Math/sin (range 0 6.28 0.01))]\n    (= (split-by-predicate data #(<= -0.01 % 0.01) 2)\n       (map #(apply subsequence data %) (split-by-predicate-positions data #(<= -0.01 % 0.01) 2 1))))\n~~~\n  "],"~$mapify",["^ ","^H",null,"^I",["^ ","^J","^;","^K",261,"^L",7,"^M",261,"^N",13,"^O",["^P",["^Q",["^P",[["~$f","~$s"]]]]],"^R","\n  Takes a seq, and returns a map where the keys are the result of applying f to the elements in the seq.\n  The result of f should be unique for each element in the seq, otherwise you will loose some data.\n  If it is not unique, consider using [group-by](https://clojuredocs.org/clojure.core/group-by).\n\n~~~klipse\n  (mapify inc (range 5) )\n~~~\n  "],"^:","~$gadjett.collections/mapify","^T",false,"^J","gadjett/collections.cljc","^N",13,"^U",["^P",[["~$f","~$s"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",261,"^M",261,"^X",2,"^Y",true,"^O",["^P",["^Q",["^P",[["~$f","~$s"]]]]],"^R","\n  Takes a seq, and returns a map where the keys are the result of applying f to the elements in the seq.\n  The result of f should be unique for each element in the seq, otherwise you will loose some data.\n  If it is not unique, consider using [group-by](https://clojuredocs.org/clojure.core/group-by).\n\n~~~klipse\n  (mapify inc (range 5) )\n~~~\n  "],"~$submap?",["^ ","^H",null,"^I",["^ ","^J","^;","^K",373,"^L",7,"^M",373,"^N",14,"^O",["^P",["^Q",["^P",[["~$m1","~$m2"]]]]],"^R","Checks if `m1` is a submap of `m2`.\n  Map `m1` is a submap of `m2` if all key/value pairs in `m1` exist in `m2`.\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2})\n~~~\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2 :c nil})\n~~~\n  "],"^:","~$gadjett.collections/submap?","^T",false,"^J","gadjett/collections.cljc","^N",14,"^U",["^P",[["^1B","^1C"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",373,"^M",373,"^X",2,"^Y",true,"^O",["^P",["^Q",["^P",[["^1B","^1C"]]]]],"^R","Checks if `m1` is a submap of `m2`.\n  Map `m1` is a submap of `m2` if all key/value pairs in `m1` exist in `m2`.\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2})\n~~~\n\n~~~klipse\n  (submap? {:a 1} {:a 1 :b 2 :c nil})\n~~~\n  "],"~$positions",["^ ","^H",null,"^I",["^ ","^J","^;","^K",309,"^L",7,"^M",309,"^N",16,"^O",["^P",["^Q",["^P",[["~$coll-of-lengths","~$&",["^ ","~:or",["^ ","~$first-val",0,"~$max-val","~$infinity"],"~:keys",["^1I","^1H"]]]]]]],"^R","Receives a collection of lengths and returns a list of start and end positions. Options:\n  * `max-val`: (default `infinity`) - max value for `end`\n  * `first-val`: (default 0) - first value of `start`\n\n~~~klipse\n  (positions '(10 10 20) :first-val 100 :max-val 137)\n~~~\n\n  ","~:top-fn",["^ ","^T",true,"^X",1,"^U",[["^P",["^1F",["^ ","^1G",["^ ","^1H",0,"^1I","^1J"],"^1K",["^1I","^1H"]]]]],"^O",["^P",[["^1F","~$&",["^ ","^1G",["^ ","^1H",0,"^1I","^1J"],"^1K",["^1I","^1H"]]]]],"^W",["^P",[null]]]],"^:","~$gadjett.collections/positions","^T",true,"^J","gadjett/collections.cljc","^N",16,"^1L",["^ ","^T",true,"^X",1,"^U",[["^P",["^1F",["^ ","^1G",["^ ","^1H",0,"^1I","^1J"],"^1K",["^1I","^1H"]]]]],"^O",["^P",[["^1F","~$&",["^ ","^1G",["^ ","^1H",0,"^1I","^1J"],"^1K",["^1I","^1H"]]]]],"^W",["^P",[null]]],"^U",[["^P",["^1F",["^ ","^1G",["^ ","^1H",0,"^1I","^1J"],"^1K",["^1I","^1H"]]]]],"^V",null,"^W",["^P",[null]],"^L",1,"^K",309,"^M",309,"^X",1,"^Y",true,"^O",["^P",[["^1F","~$&",["^ ","^1G",["^ ","^1H",0,"^1I","^1J"],"^1K",["^1I","^1H"]]]]],"^R","Receives a collection of lengths and returns a list of start and end positions. Options:\n  * `max-val`: (default `infinity`) - max value for `end`\n  * `first-val`: (default 0) - first value of `start`\n\n~~~klipse\n  (positions '(10 10 20) :first-val 100 :max-val 137)\n~~~\n\n  "],"~$filter-map",["^ ","^H",null,"^I",["^ ","^J","^;","^K",205,"^L",7,"^M",205,"^N",17,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Run a function on the elements of a map and keep only those elements for which the function returns true\n  \n~~~klipse\n  (filter-map even? {:a 1 :b 2 :c 3})\n~~~\n  "],"^:","~$gadjett.collections/filter-map","^T",false,"^J","gadjett/collections.cljc","^N",17,"^U",["^P",[["~$f","~$m"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",205,"^M",205,"^X",2,"^Y",true,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Run a function on the elements of a map and keep only those elements for which the function returns true\n  \n~~~klipse\n  (filter-map even? {:a 1 :b 2 :c 3})\n~~~\n  "],"~$vec->map",["^ ","^H",null,"^I",["^ ","^J","^;","^K",19,"^L",7,"^M",19,"^N",15,"^O",["^P",["^Q",["^P",[["~$vec"]]]]],"^R","Converts a 2d vec to a hash-map.\n\n~~~klipse\n   (vec->map [[:a 1] [:b 2]])\n~~~\n   "],"^:","~$gadjett.collections/vec->map","^T",false,"^J","gadjett/collections.cljc","^N",15,"^U",["^P",[["^1Q"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",19,"^M",19,"^X",1,"^Y",true,"^O",["^P",["^Q",["^P",[["^1Q"]]]]],"^R","Converts a 2d vec to a hash-map.\n\n~~~klipse\n   (vec->map [[:a 1] [:b 2]])\n~~~\n   "],"~$assoc-cyclic",["^ ","^H",null,"^I",["^ ","^J","^;","^K",161,"^L",7,"^M",161,"^N",19,"^O",["^P",["^Q",["^P",[["^1<","~$k","~$v"],["^1<","~$k","~$v","~$n"]]]]],"^R","Assoc a key-value pair to a map popping out an element of the map.\n  If the key already exists, no element is popped out.\n  If `n` is supplied, no elmement is popped out if the map has less than `n` entries.\n\n~~~klipse\n  (-> {:a 1 :b 2 :c 3}\n      (assoc-cyclic :d 4)\n      (assoc-cyclic :e 5)\n      (assoc-cyclic :f 6)\n      (assoc-cyclic :g 7))\n~~~\n  ","^1L",["^ ","^T",false,"^X",4,"^U",["^P",[["^1<","~$k","~$v"],["^1<","~$k","~$v","~$n"]]],"^O",["^P",[["^1<","~$k","~$v"],["^1<","~$k","~$v","~$n"]]],"^W",["^P",[null,null]]]],"^:","~$gadjett.collections/assoc-cyclic","^T",false,"^J","gadjett/collections.cljc","^N",19,"^1L",["^ ","^T",false,"^X",4,"^U",["^P",[["^1<","~$k","~$v"],["^1<","~$k","~$v","~$n"]]],"^O",["^P",[["^1<","~$k","~$v"],["^1<","~$k","~$v","~$n"]]],"^W",["^P",[null,null]]],"^U",["^P",[["^1<","~$k","~$v"],["^1<","~$k","~$v","~$n"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",161,"^M",161,"^X",4,"^Y",true,"^O",["^P",[["^1<","~$k","~$v"],["^1<","~$k","~$v","~$n"]]],"^R","Assoc a key-value pair to a map popping out an element of the map.\n  If the key already exists, no element is popped out.\n  If `n` is supplied, no elmement is popped out if the map has less than `n` entries.\n\n~~~klipse\n  (-> {:a 1 :b 2 :c 3}\n      (assoc-cyclic :d 4)\n      (assoc-cyclic :e 5)\n      (assoc-cyclic :f 6)\n      (assoc-cyclic :g 7))\n~~~\n  "],"^1J",["^ ","^:","~$gadjett.collections/infinity","^J","gadjett/collections.cljc","^K",6,"^L",1,"^M",6,"^N",14,"^I",["^ ","^J","^;","^K",6,"^L",6,"^M",6,"^N",14]],"~$subsequence",["^ ","^H",null,"^I",["^ ","^J","^;","^K",388,"^L",7,"^M",388,"^N",18,"^O",["^P",["^Q",["^P",[["^1<","~$start","~$end"]]]]],"^R","\n  Returns a lazy subsequence of `coll`, starting at `start, ending at `end` (not included).\n\n~~~klipse\n  (subsequence (range) 10 20)\n~~~\n  "],"^:","~$gadjett.collections/subsequence","^T",false,"^J","gadjett/collections.cljc","^N",18,"^U",["^P",[["^1<","^1W","^1X"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",388,"^M",388,"^X",3,"^Y",true,"^O",["^P",["^Q",["^P",[["^1<","^1W","^1X"]]]]],"^R","\n  Returns a lazy subsequence of `coll`, starting at `start, ending at `end` (not included).\n\n~~~klipse\n  (subsequence (range) 10 20)\n~~~\n  "],"~$edn-zip",["^ ","^H",null,"^I",["^ ","^J","^;","^K",546,"^L",7,"^M",546,"^N",14,"^O",["^P",["^Q",["^P",[["~$root"]]]]],"^R","A zipper for `edn`.\n\n~~~klipse\n  (edn-zip {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"^:","~$gadjett.collections/edn-zip","^T",false,"^J","gadjett/collections.cljc","^N",14,"^U",["^P",[["^1["]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",546,"^M",546,"^X",1,"^Y",true,"^O",["^P",["^Q",["^P",[["^1["]]]]],"^R","A zipper for `edn`.\n\n~~~klipse\n  (edn-zip {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"~$fix-blank-lines",["^ ","^H",null,"^I",["^ ","^J","^;","^K",612,"^L",7,"^M",612,"^N",22,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Removes blank lines from the begining and from the end (not from the middle)\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (fix-blank-lines lines))\n~~~\n  "],"^:","~$gadjett.collections/fix-blank-lines","^T",false,"^J","gadjett/collections.cljc","^N",22,"^U",["^P",[["~$s"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",612,"^M",612,"^X",1,"^Y",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Removes blank lines from the begining and from the end (not from the middle)\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (fix-blank-lines lines))\n~~~\n  "],"~$map-to-object",["^ ","^H",null,"^I",["^ ","^J","^;","^K",251,"^L",7,"^M",251,"^N",20,"^O",["^P",["^Q",["^P",[["~$f","~$lst"]]]]],"^R","Returns a map whose keys are the elements of `lst` and values are mapped by `f`.\n\n~~~klipse\n  (map-to-object inc (range 5))\n~~~\n  "],"^:","~$gadjett.collections/map-to-object","^T",false,"^J","gadjett/collections.cljc","^N",20,"^U",["^P",[["~$f","^24"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",251,"^M",251,"^X",2,"^Y",true,"^O",["^P",["^Q",["^P",[["~$f","^24"]]]]],"^R","Returns a map whose keys are the elements of `lst` and values are mapped by `f`.\n\n~~~klipse\n  (map-to-object inc (range 5))\n~~~\n  "],"~$deep-merge",["^ ","^H",null,"^I",["^ ","^J","^;","^K",468,"^L",7,"^M",468,"^N",17,"^O",["^P",["^Q",["^P",[["~$&","~$maps"]]]]],"^R"," Deep merges maps.\n\n~~~klipse\n(deep-merge {} {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}} {:a {:b 1}, :c {:e 4, :d 2000, :f {:g 9000}}})\n~~~\n","^1L",["^ ","^T",true,"^X",0,"^U",[["^P",["^27"]]],"^O",["^P",[["~$&","^27"]]],"^W",["^P",[null]]]],"^:","~$gadjett.collections/deep-merge","^T",true,"^J","gadjett/collections.cljc","^N",17,"^1L",["^ ","^T",true,"^X",0,"^U",[["^P",["^27"]]],"^O",["^P",[["~$&","^27"]]],"^W",["^P",[null]]],"^U",[["^P",["^27"]]],"^V",null,"^W",["^P",[null]],"^L",1,"^K",468,"^M",468,"^X",0,"^Y",true,"^O",["^P",[["~$&","^27"]]],"^R"," Deep merges maps.\n\n~~~klipse\n(deep-merge {} {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}} {:a {:b 1}, :c {:e 4, :d 2000, :f {:g 9000}}})\n~~~\n"],"~$mean",["^ ","^H",null,"^I",["^ ","^J","^;","^K",98,"^L",7,"^M",98,"^N",11,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^R","Calculates the mean (a.k.a average) of a sequence of numbers.\n\n~~~klipse\n  (mean [1 2 10 -1 12.3])\n~~~\n  "],"^:","~$gadjett.collections/mean","^T",false,"^J","gadjett/collections.cljc","^N",11,"^U",["^P",[["~$x"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",98,"^M",98,"^X",1,"^Y",true,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^R","Calculates the mean (a.k.a average) of a sequence of numbers.\n\n~~~klipse\n  (mean [1 2 10 -1 12.3])\n~~~\n  "],"~$loc-my-replace",["^ ","^H",null,"^I",["^ ","^J","^;","^K",571,"^L",8,"^M",571,"^N",22,"~:private",true,"^O",["^P",["^Q",["^P",[["~$smap","~$loc"]]]]]],"^2<",true,"^:","~$gadjett.collections/loc-my-replace","^T",false,"^J","gadjett/collections.cljc","^N",22,"^U",["^P",[["^2=","^2>"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",571,"^M",571,"^X",2,"^Y",true,"^O",["^P",["^Q",["^P",[["^2=","^2>"]]]]]],"~$map-object-kv",["^ ","^H",null,"^I",["^ ","^J","^;","^K",73,"^L",7,"^M",73,"^N",20,"^O",["^P",["^Q",["^P",[["~$fk","~$fv","~$m"]]]]],"^R","Returns a map with the keys mapped by `fk` and the values mapped by `fv`.\n\n~~~klipse\n    (map-object-kv name inc {:a 1 :b 2 :c 3})\n~~~\n"],"^:","~$gadjett.collections/map-object-kv","^T",false,"^J","gadjett/collections.cljc","^N",20,"^U",["^P",[["^2A","^2B","~$m"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",73,"^M",73,"^X",3,"^Y",true,"^O",["^P",["^Q",["^P",[["^2A","^2B","~$m"]]]]],"^R","Returns a map with the keys mapped by `fk` and the values mapped by `fv`.\n\n~~~klipse\n    (map-object-kv name inc {:a 1 :b 2 :c 3})\n~~~\n"],"~$flatten-keys",["^ ","^H",null,"^I",["^ ","^J","^;","^K",418,"^L",7,"^M",418,"^N",19,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","\nFlatten the keys of a nested map.\nThanks to [Jay Fields](http://blog.jayfields.com/2010/09/clojure-flatten-keys.html)\n\n~~~klipse\n(flatten-keys {:a {:b 1} :c {:d 2 :e 4 :f {:g 8}}})\n~~~\n"],"^:","~$gadjett.collections/flatten-keys","^T",false,"^J","gadjett/collections.cljc","^N",19,"^U",["^P",[["~$m"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",418,"^M",418,"^X",1,"^Y",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","\nFlatten the keys of a nested map.\nThanks to [Jay Fields](http://blog.jayfields.com/2010/09/clojure-flatten-keys.html)\n\n~~~klipse\n(flatten-keys {:a {:b 1} :c {:d 2 :e 4 :f {:g 8}}})\n~~~\n"],"~$flatten-keys*",["^ ","^H",null,"^I",["^ ","^J","^;","^K",411,"^L",8,"^M",411,"^N",21,"^2<",true,"^O",["^P",["^Q",["^P",[["~$a","^16","~$m"]]]]]],"^2<",true,"^:","~$gadjett.collections/flatten-keys*","^T",false,"^J","gadjett/collections.cljc","^N",21,"^U",["^P",[["~$a","^16","~$m"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",411,"^M",411,"^X",3,"^Y",true,"^O",["^P",["^Q",["^P",[["~$a","^16","~$m"]]]]]],"~$compactize-map",["^ ","^H",null,"^I",["^ ","^J","^;","^K",195,"^L",7,"^M",195,"^N",21,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Removes entries with `nil` values.\n\n~~~klipse\n  (compactize-map {:a 1 :b nil :c 3})\n~~~\n  "],"^:","~$gadjett.collections/compactize-map","^T",false,"^J","gadjett/collections.cljc","^N",21,"^U",["^P",[["~$m"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",195,"^M",195,"^X",1,"^Y",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Removes entries with `nil` values.\n\n~~~klipse\n  (compactize-map {:a 1 :b nil :c 3})\n~~~\n  "],"~$partition-between",["^ ","^H",null,"^I",["^ ","^J","^;","^K",516,"^L",7,"^M",516,"^N",24,"^O",["^P",["^Q",["^P",[["^1=","^1<"]]]]],"^R","Splits a collection between two items according to predicate `pred` - which means split the sequence on breaking point.\n\n  See: [here](http://stackoverflow.com/questions/23207490/partition-a-seq-by-a-windowing-predicate-in-clojure)\n\n  For instance, split each time the series stop being ascending:\n\n~~~klipse\n(partition-between > [1 2 4 9 8 7 6 5 1 2 4 5 11])\n~~~\n"],"^:","~$gadjett.collections/partition-between","^T",false,"^J","gadjett/collections.cljc","^N",24,"^U",["^P",[["^1=","^1<"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",516,"^M",516,"^X",2,"^Y",true,"^O",["^P",["^Q",["^P",[["^1=","^1<"]]]]],"^R","Splits a collection between two items according to predicate `pred` - which means split the sequence on breaking point.\n\n  See: [here](http://stackoverflow.com/questions/23207490/partition-a-seq-by-a-windowing-predicate-in-clojure)\n\n  For instance, split each time the series stop being ascending:\n\n~~~klipse\n(partition-between > [1 2 4 9 8 7 6 5 1 2 4 5 11])\n~~~\n"],"~$take-from-map",["^ ","^H",null,"^I",["^ ","^J","^;","^K",440,"^L",7,"^M",440,"^N",20,"^O",["^P",["^Q",["^P",[["~$n","~$m"]]]]],"^R","Creates a map with n leaves which are nested values of m.\n  The following assertion holds:\n\n~~~clojure\n      (>= n (count (flatten-keys (take-from-map n m)))))))\n~~~\n\n~~~klipse\n  (take-from-map 3 {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"^:","~$gadjett.collections/take-from-map","^T",false,"^J","gadjett/collections.cljc","^N",20,"^U",["^P",[["~$n","~$m"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",440,"^M",440,"^X",2,"^Y",true,"^O",["^P",["^Q",["^P",[["~$n","~$m"]]]]],"^R","Creates a map with n leaves which are nested values of m.\n  The following assertion holds:\n\n~~~clojure\n      (>= n (count (flatten-keys (take-from-map n m)))))))\n~~~\n\n~~~klipse\n  (take-from-map 3 {:a {:b 1}, :c {:e 4, :d 2, :f {:g 8}}})\n~~~\n  "],"~$compact",["^ ","^H",null,"^I",["^ ","^J","^;","^K",645,"^L",11,"^M",645,"^N",18,"^O",["^P",["^Q",["^P",[["~$x","~$&",["^ ","^17","~$args","^1G",["^ ","~$max-elements-in-coll",10,"~$max-chars-in-str",20],"^1K",["^2P","^2Q"]]]]]]],"^R","\n(clojurescript only)\n\nCompacts an expression by taking only the first `max-elements-in-coll` from collections and first `max-chars-in-str` from strings. Functions are displayed as \"lambda()\".\n\nIt works recursively. It is useful for logging and reporting.\n\nDefault settings:\n\n- `max-elements-in-coll` 10\n- `max-chars-in-str` 20\n\n~~~klipse\n(compact {:infinite-list (range)\n          :long-str \"a very very very very long string - too long to be true\"\n                                                      :long-map (zipmap (range 100) (range 100))\n                                                        :function #(+ 1 2)})\n~~~\n                  ","^1L",["^ ","^T",true,"^X",1,"^U",[["^P",["~$x",["^ ","^17","^2O","^1G",["^ ","^2P",10,"^2Q",20],"^1K",["^2P","^2Q"]]]]],"^O",["^P",[["~$x","~$&",["^ ","^17","^2O","^1G",["^ ","^2P",10,"^2Q",20],"^1K",["^2P","^2Q"]]]]],"^W",["^P",[null]]]],"^:","~$gadjett.collections/compact","^T",true,"^J","gadjett/collections.cljc","^N",18,"^1L",["^ ","^T",true,"^X",1,"^U",[["^P",["~$x",["^ ","^17","^2O","^1G",["^ ","^2P",10,"^2Q",20],"^1K",["^2P","^2Q"]]]]],"^O",["^P",[["~$x","~$&",["^ ","^17","^2O","^1G",["^ ","^2P",10,"^2Q",20],"^1K",["^2P","^2Q"]]]]],"^W",["^P",[null]]],"^U",[["^P",["~$x",["^ ","^17","^2O","^1G",["^ ","^2P",10,"^2Q",20],"^1K",["^2P","^2Q"]]]]],"^V",null,"^W",["^P",[null]],"^L",5,"^K",645,"^M",645,"^X",1,"^Y",true,"^O",["^P",[["~$x","~$&",["^ ","^17","^2O","^1G",["^ ","^2P",10,"^2Q",20],"^1K",["^2P","^2Q"]]]]],"^R","\n(clojurescript only)\n\nCompacts an expression by taking only the first `max-elements-in-coll` from collections and first `max-chars-in-str` from strings. Functions are displayed as \"lambda()\".\n\nIt works recursively. It is useful for logging and reporting.\n\nDefault settings:\n\n- `max-elements-in-coll` 10\n- `max-chars-in-str` 20\n\n~~~klipse\n(compact {:infinite-list (range)\n          :long-str \"a very very very very long string - too long to be true\"\n                                                      :long-map (zipmap (range 100) (range 100))\n                                                        :function #(+ 1 2)})\n~~~\n                  "],"~$map-with-index",["^ ","^H",null,"^I",["^ ","^J","^;","^K",274,"^L",7,"^M",274,"^N",21,"^O",["^P",["^Q",["^P",[["~$s","~$idx-key","~$val-key"]]]]],"^R","Maps a sequence to a sequence of maps with index and value\n\n~~~klipse\n      (map-with-index [10 20 30] :idx :val)\n~~~\n  "],"^:","~$gadjett.collections/map-with-index","^T",false,"^J","gadjett/collections.cljc","^N",21,"^U",["^P",[["~$s","^2T","^2U"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",274,"^M",274,"^X",3,"^Y",true,"^O",["^P",["^Q",["^P",[["~$s","^2T","^2U"]]]]],"^R","Maps a sequence to a sequence of maps with index and value\n\n~~~klipse\n      (map-with-index [10 20 30] :idx :val)\n~~~\n  "],"~$map-object-with-key",["^ ","^H",null,"^I",["^ ","^J","^;","^K",63,"^L",7,"^M",63,"^N",26,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` must be a `2-ary` function that receives the key and the value as arguments.\n\n~~~klipse\n  (map-object-with-key list {:a 1 :b 2 :c 3})\n~~~\n  "],"^:","~$gadjett.collections/map-object-with-key","^T",false,"^J","gadjett/collections.cljc","^N",26,"^U",["^P",[["~$f","~$m"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",63,"^M",63,"^X",2,"^Y",true,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` must be a `2-ary` function that receives the key and the value as arguments.\n\n~~~klipse\n  (map-object-with-key list {:a 1 :b 2 :c 3})\n~~~\n  "],"~$deep-merge*",["^ ","^H",null,"^I",["^ ","^J","^;","^K",459,"^L",8,"^M",459,"^N",19,"^2<",true,"^O",["^P",["^Q",["^P",[["~$&","^27"]]]]],"^1L",["^ ","^T",true,"^X",0,"^U",[["^P",["^27"]]],"^O",["^P",[["~$&","^27"]]],"^W",["^P",[null]]]],"^2<",true,"^:","~$gadjett.collections/deep-merge*","^T",true,"^J","gadjett/collections.cljc","^N",19,"^1L",["^ ","^T",true,"^X",0,"^U",[["^P",["^27"]]],"^O",["^P",[["~$&","^27"]]],"^W",["^P",[null]]],"^U",[["^P",["^27"]]],"^V",null,"^W",["^P",[null]],"^L",1,"^K",459,"^M",459,"^X",0,"^Y",true,"^O",["^P",[["~$&","^27"]]]],"~$range-till-end",["^ ","^H",null,"^I",["^ ","^J","^;","^K",125,"^L",7,"^M",125,"^N",21,"^O",["^P",["^Q",["^P",[["~$&","^2O"]]]]],"^R","Like `range` but including the `end`.\n\n~~~klipse\n  (range-till-end 10)\n~~~\n\n~~~klipse\n(range-till-end 10 18)\n~~~\n\n~~~klipse\n(range-till-end 10 100 5)\n~~~\n\n  ","^1L",["^ ","^T",true,"^X",0,"^U",[["^P",["^2O"]]],"^O",["^P",[["~$&","^2O"]]],"^W",["^P",[null]]]],"^:","~$gadjett.collections/range-till-end","^T",true,"^J","gadjett/collections.cljc","^N",21,"^1L",["^ ","^T",true,"^X",0,"^U",[["^P",["^2O"]]],"^O",["^P",[["~$&","^2O"]]],"^W",["^P",[null]]],"^U",[["^P",["^2O"]]],"^V",null,"^W",["^P",[null]],"^L",1,"^K",125,"^M",125,"^X",0,"^Y",true,"^O",["^P",[["~$&","^2O"]]],"^R","Like `range` but including the `end`.\n\n~~~klipse\n  (range-till-end 10)\n~~~\n\n~~~klipse\n(range-till-end 10 18)\n~~~\n\n~~~klipse\n(range-till-end 10 100 5)\n~~~\n\n  "],"~$nearest-of-seq",["^ ","^H",null,"^I",["^ ","^J","^;","^K",238,"^L",7,"^M",238,"^N",21,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^R","Maps each element of `b` to its nearest element in `a`.\n  If `a` is empty, returns `b`.\n\n~~~klipse\n  (nearest-of-seq (range 5) [1.2 3.4 4])\n~~~\n  "],"^:","~$gadjett.collections/nearest-of-seq","^T",false,"^J","gadjett/collections.cljc","^N",21,"^U",["^P",[["~$a","~$b"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",238,"^M",238,"^X",2,"^Y",true,"^O",["^P",["^Q",["^P",[["~$a","~$b"]]]]],"^R","Maps each element of `b` to its nearest element in `a`.\n  If `a` is empty, returns `b`.\n\n~~~klipse\n  (nearest-of-seq (range 5) [1.2 3.4 4])\n~~~\n  "],"~$range-with-end",["^ ","^H",null,"^I",["^ ","^J","^;","^K",120,"^L",8,"^M",120,"^N",22,"^2<",true,"^O",["^P",["^Q",["^P",[["^1X"],["^1W","^1X"],["^1W","^1X","~$steps"]]]]],"^1L",["^ ","^T",false,"^X",3,"^U",["^P",[["^1X"],["^1W","^1X"],["^1W","^1X","^34"]]],"^O",["^P",[["^1X"],["^1W","^1X"],["^1W","^1X","^34"]]],"^W",["^P",[null,null,null]]]],"^2<",true,"^:","~$gadjett.collections/range-with-end","^T",false,"^J","gadjett/collections.cljc","^N",22,"^1L",["^ ","^T",false,"^X",3,"^U",["^P",[["^1X"],["^1W","^1X"],["^1W","^1X","^34"]]],"^O",["^P",[["^1X"],["^1W","^1X"],["^1W","^1X","^34"]]],"^W",["^P",[null,null,null]]],"^U",["^P",[["^1X"],["^1W","^1X"],["^1W","^1X","^34"]]],"^V",null,"^W",["^P",[null,null,null]],"^L",1,"^K",120,"^M",120,"^X",3,"^Y",true,"^O",["^P",[["^1X"],["^1W","^1X"],["^1W","^1X","^34"]]]],"~$branches-and-leaves",["^ ","^H",null,"^I",["^ ","^J","^;","^K",480,"^L",7,"^M",480,"^N",26,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Returns all branches and leaves off a nested map object.\n\n~~~klipse\n(branches-and-leaves {:a {:b 1 :c {:d 2}} :e 3})\n~~~\n  "],"^:","~$gadjett.collections/branches-and-leaves","^T",false,"^J","gadjett/collections.cljc","^N",26,"^U",["^P",[["~$m"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",480,"^M",480,"^X",1,"^Y",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Returns all branches and leaves off a nested map object.\n\n~~~klipse\n(branches-and-leaves {:a {:b 1 :c {:d 2}} :e 3})\n~~~\n  "],"~$remove-blank-lines",["^ ","^H",null,"^I",["^ ","^J","^;","^K",630,"^L",7,"^M",630,"^N",25,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Removes blank lines.\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (remove-blank-lines lines))\n~~~\n  "],"^:","~$gadjett.collections/remove-blank-lines","^T",false,"^J","gadjett/collections.cljc","^N",25,"^U",["^P",[["~$s"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",630,"^M",630,"^X",1,"^Y",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Removes blank lines.\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (remove-blank-lines lines))\n~~~\n  "],"~$filter-branches",["^ ","^H",null,"^I",["^ ","^J","^;","^K",494,"^L",7,"^M",494,"^N",22,"^O",["^P",["^Q",["^P",[["~$m","~$p"]]]]],"^R","Filters branches of a (nested) map `m` according to a predicate `m`.\n\n~~~klipse\n(filter-branches {:x {:id 19 :b 1 :c {:id 2}} :e 3} :id)\n~~~\n  "],"^:","~$gadjett.collections/filter-branches","^T",false,"^J","gadjett/collections.cljc","^N",22,"^U",["^P",[["~$m","~$p"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",494,"^M",494,"^X",2,"^Y",true,"^O",["^P",["^Q",["^P",[["~$m","~$p"]]]]],"^R","Filters branches of a (nested) map `m` according to a predicate `m`.\n\n~~~klipse\n(filter-branches {:x {:id 19 :b 1 :c {:id 2}} :e 3} :id)\n~~~\n  "],"~$comment?",["^ ","^H",null,"^I",["^ ","^J","^;","^K",593,"^L",8,"^M",593,"^N",16,"^2<",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]]],"^2<",true,"^:","~$gadjett.collections/comment?","^T",false,"^J","gadjett/collections.cljc","^N",16,"^U",["^P",[["~$s"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",593,"^M",593,"^X",1,"^Y",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]]],"~$out-of-bound?",["^ ","^H",null,"^I",["^ ","^J","^;","^K",506,"^L",7,"^M",506,"^N",20,"^O",["^P",["^Q",["^P",[["~$v","~$idx"]]]]],"^R","Checks if index `idx` is in range of vector `v`. More efficient than `(get v idx)`\n\n~~~klipse\n    (map #(out-of-bound? [1 2 3] %) [-1 0 1 2 3 4])\n~~~\n  "],"^:","~$gadjett.collections/out-of-bound?","^T",false,"^J","gadjett/collections.cljc","^N",20,"^U",["^P",[["~$v","^3?"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",506,"^M",506,"^X",2,"^Y",true,"^O",["^P",["^Q",["^P",[["~$v","^3?"]]]]],"^R","Checks if index `idx` is in range of vector `v`. More efficient than `(get v idx)`\n\n~~~klipse\n    (map #(out-of-bound? [1 2 3] %) [-1 0 1 2 3 4])\n~~~\n  "],"~$map-2d-vec",["^ ","^H",null,"^I",["^ ","^J","^;","^K",29,"^L",7,"^M",29,"^N",17,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-2d-vec inc [[:a 1] [:b 2]])\n~~~\n"],"^:","~$gadjett.collections/map-2d-vec","^T",false,"^J","gadjett/collections.cljc","^N",17,"^U",["^P",[["~$f","~$m"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",29,"^M",29,"^X",2,"^Y",true,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-2d-vec inc [[:a 1] [:b 2]])\n~~~\n"],"~$split-by-predicate",["^ ","^H",null,"^I",["^ ","^J","^;","^K",324,"^L",7,"^M",324,"^N",25,"^O",["^P",["^Q",["^P",[["^1<","^1=","~$n"]]]]],"^R","Splits a collection to items where the separator is a repetition of at least n elements that satisfy `pred`.\n\n  Inspired by: [this question](http://stackoverflow.com/a/23555616/813665).\n\n~~~klipse\n  (split-by-predicate (shuffle (range 30)) even? 2)\n~~~\n  "],"^:","~$gadjett.collections/split-by-predicate","^T",false,"^J","gadjett/collections.cljc","^N",25,"^U",["^P",[["^1<","^1=","~$n"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",324,"^M",324,"^X",3,"^Y",true,"^O",["^P",["^Q",["^P",[["^1<","^1=","~$n"]]]]],"^R","Splits a collection to items where the separator is a repetition of at least n elements that satisfy `pred`.\n\n  Inspired by: [this question](http://stackoverflow.com/a/23555616/813665).\n\n~~~klipse\n  (split-by-predicate (shuffle (range 30)) even? 2)\n~~~\n  "],"~$abs",["^ ","^H",null,"^I",["^ ","^J","^;","^K",215,"^L",7,"^M",215,"^N",10,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^R","Absolute value of a number\n\n~~~klipse\n  (map abs (range -5 5))\n~~~\n\n"],"^:","~$gadjett.collections/abs","^T",false,"^J","gadjett/collections.cljc","^N",10,"^U",["^P",[["~$x"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",215,"^M",215,"^X",1,"^Y",true,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^R","Absolute value of a number\n\n~~~klipse\n  (map abs (range -5 5))\n~~~\n\n"],"~$append-cyclic",["^ ","^H",null,"^I",["^ ","^J","^;","^K",145,"^L",7,"^M",145,"^N",20,"^O",["^P",["^Q",["^P",[["^24","~$a"]]]]],"^R","Appends an element to a list popping out the first element.\n\n~~~klipse\n  (-> (repeat 3 nil)\n      (append-cyclic 1)\n      (append-cyclic 2)\n      (append-cyclic 3)\n      (append-cyclic 4))\n~~~\n  "],"^:","~$gadjett.collections/append-cyclic","^T",false,"^J","gadjett/collections.cljc","^N",20,"^U",["^P",[["^24","~$a"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",145,"^M",145,"^X",2,"^Y",true,"^O",["^P",["^Q",["^P",[["^24","~$a"]]]]],"^R","Appends an element to a list popping out the first element.\n\n~~~klipse\n  (-> (repeat 3 nil)\n      (append-cyclic 1)\n      (append-cyclic 2)\n      (append-cyclic 3)\n      (append-cyclic 4))\n~~~\n  "],"~$collify",["^ ","^H",null,"^I",["^ ","^J","^;","^K",532,"^L",7,"^M",532,"^N",14,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Ensure `s` is a collection: if `s` is a collection returns it; otherwise returns (s)\n\n~~~klipse\n(collify 1)\n~~~\n\n~~~klipse\n(collify [1 2 3])\n~~~\n  "],"^:","~$gadjett.collections/collify","^T",false,"^J","gadjett/collections.cljc","^N",14,"^U",["^P",[["~$s"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",532,"^M",532,"^X",1,"^Y",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Ensure `s` is a collection: if `s` is a collection returns it; otherwise returns (s)\n\n~~~klipse\n(collify 1)\n~~~\n\n~~~klipse\n(collify [1 2 3])\n~~~\n  "],"~$map-2d-vec-kv",["^ ","^H",null,"^I",["^ ","^J","^;","^K",40,"^L",7,"^M",40,"^N",20,"^O",["^P",["^Q",["^P",[["^2A","^2B","~$m"]]]]],"^R","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`fk` is a `1-ary` function that receives the key.\n`fv` is a `1-ary` function that receives the value.\n\n~~~klipse\n    (map-2d-vec-kv name inc [[:a 1] [:b 2]])\n~~~\n"],"^:","~$gadjett.collections/map-2d-vec-kv","^T",false,"^J","gadjett/collections.cljc","^N",20,"^U",["^P",[["^2A","^2B","~$m"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",40,"^M",40,"^X",3,"^Y",true,"^O",["^P",["^Q",["^P",[["^2A","^2B","~$m"]]]]],"^R","Maps the values of a `2D` vector where each element of the vector is a key-value pair.\n`fk` is a `1-ary` function that receives the key.\n`fv` is a `1-ary` function that receives the value.\n\n~~~klipse\n    (map-2d-vec-kv name inc [[:a 1] [:b 2]])\n~~~\n"],"~$max-and-min",["^ ","^H",null,"^I",["^ ","^J","^;","^K",183,"^L",7,"^M",183,"^N",18,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^R","Returns a couple of the `max` and the `min` of a sequence.\n\n~~~klipse\n  (max-and-min (range 5))\n~~~\n  "],"^:","~$gadjett.collections/max-and-min","^T",false,"^J","gadjett/collections.cljc","^N",18,"^U",["^P",[["~$x"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",183,"^M",183,"^X",1,"^Y",true,"^O",["^P",["^Q",["^P",[["~$x"]]]]],"^R","Returns a couple of the `max` and the `min` of a sequence.\n\n~~~klipse\n  (max-and-min (range 5))\n~~~\n  "],"~$index-of",["^ ","^H",null,"^I",["^ ","^J","^;","^K",400,"^L",7,"^M",400,"^N",15,"^O",["^P",["^Q",["^P",[["~$s","~$element"]]]]],"^R","Returns the index of an element in a sequence or `-1` if not present.\n\n  ~~~klipse\n  (index-of (range 100) 18)\n  ~~~\n  "],"^:","~$gadjett.collections/index-of","^T",false,"^J","gadjett/collections.cljc","^N",15,"^U",["^P",[["~$s","^3P"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",400,"^M",400,"^X",2,"^Y",true,"^O",["^P",["^Q",["^P",[["~$s","^3P"]]]]],"^R","Returns the index of an element in a sequence or `-1` if not present.\n\n  ~~~klipse\n  (index-of (range 100) 18)\n  ~~~\n  "],"~$nearest-of-ss",["^ ","^H",null,"^I",["^ ","^J","^;","^K",226,"^L",7,"^M",226,"^N",20,"^O",["^P",["^Q",["^P",[["~$ss","~$x"]]]]],"^R","Returns the nearest number to `x` of a sorted set\n\n~~~klipse\n  (nearest-of-ss (apply sorted-set (range 5)) 1.2)\n~~~\n  "],"^:","~$gadjett.collections/nearest-of-ss","^T",false,"^J","gadjett/collections.cljc","^N",20,"^U",["^P",[["^3S","~$x"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",226,"^M",226,"^X",2,"^Y",true,"^O",["^P",["^Q",["^P",[["^3S","~$x"]]]]],"^R","Returns the nearest number to `x` of a sorted set\n\n~~~klipse\n  (nearest-of-ss (apply sorted-set (range 5)) 1.2)\n~~~\n  "],"~$map-reverse-hierarchy",["^ ","^H",null,"^I",["^ ","^J","^;","^K",84,"^L",7,"^M",84,"^N",28,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Turns a hash map inside out.\n  See:  [here](http://stackoverflow.com/a/23653784/813665)\n\n~~~klipse\n  (map-reverse-hierarchy {:monday {:banana 2 :apple 3} \n                          :tuesday {:banana 5 :orange 2}})\n~~~\n"],"^:","~$gadjett.collections/map-reverse-hierarchy","^T",false,"^J","gadjett/collections.cljc","^N",28,"^U",["^P",[["~$m"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",84,"^M",84,"^X",1,"^Y",true,"^O",["^P",["^Q",["^P",[["~$m"]]]]],"^R","Turns a hash map inside out.\n  See:  [here](http://stackoverflow.com/a/23653784/813665)\n\n~~~klipse\n  (map-reverse-hierarchy {:monday {:banana 2 :apple 3} \n                          :tuesday {:banana 5 :orange 2}})\n~~~\n"],"~$remove-ending-comments",["^ ","^H",null,"^I",["^ ","^J","^;","^K",596,"^L",7,"^M",596,"^N",29,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Removes comment lines from the end.\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (remove-ending-comments lines))\n~~~\n  "],"^:","~$gadjett.collections/remove-ending-comments","^T",false,"^J","gadjett/collections.cljc","^N",29,"^U",["^P",[["~$s"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",596,"^M",596,"^X",1,"^Y",true,"^O",["^P",["^Q",["^P",[["~$s"]]]]],"^R","Removes comment lines from the end.\n\n~~~klipse\n  ; we use (char 10) for end-of-line due to technical issues with string manipulation with `codox`\n  (let [lines (clojure.string/join (char 10) [\"  \", \"aa\", \"  \", \"bb\", \" \t  \"])]\n  (remove-ending-comments lines))\n~~~\n  "],"~$map-object",["^ ","^H",null,"^I",["^ ","^J","^;","^K",52,"^L",7,"^M",52,"^N",17,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-object inc {:a 1 :b 2 :c 3})\n~~~\n  "],"^:","~$gadjett.collections/map-object","^T",false,"^J","gadjett/collections.cljc","^N",17,"^U",["^P",[["~$f","~$m"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",52,"^M",52,"^X",2,"^Y",true,"^O",["^P",["^Q",["^P",[["~$f","~$m"]]]]],"^R","Returns a map with the same keys as `m` and with the values transformed by `f`. `f` is a `1-ary` function that receives the key.\n\n~~~klipse\n  (map-object inc {:a 1 :b 2 :c 3})\n~~~\n  "],"~$my-replace",["^ ","^H",null,"^I",["^ ","^J","^;","^K",578,"^L",7,"^M",578,"^N",17,"^O",["^P",["^Q",["^P",[["^2=","~$form"]]]]],"^R","Recursively transforms `form` by replacing keys in `smap` with their\n  values, spliced. The values in `smap` must be sequences. Like clojure.walk/prewalk-replace but supports list in values.\n\n~~~klipse\n(my-replace '{go (go gadjett)} '(go (<! (timeout 100)) (go (<! timeout 0))))\n~~~\n  "],"^:","~$gadjett.collections/my-replace","^T",false,"^J","gadjett/collections.cljc","^N",17,"^U",["^P",[["^2=","^40"]]],"^V",null,"^W",["^P",[null,null]],"^L",1,"^K",578,"^M",578,"^X",2,"^Y",true,"^O",["^P",["^Q",["^P",[["^2=","^40"]]]]],"^R","Recursively transforms `form` by replacing keys in `smap` with their\n  values, spliced. The values in `smap` must be sequences. Like clojure.walk/prewalk-replace but supports list in values.\n\n~~~klipse\n(my-replace '{go (go gadjett)} '(go (<! (timeout 100)) (go (<! timeout 0))))\n~~~\n  "]],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^9",["^40","^3?","~$&","~$x","^2:","^G","^Z","^1X","^10","^2?","^15","^1;","^39","^3Z","^2A","^2>","^1?","~:max-elements-in-coll","^3;","^1A","^2K","^2M","~$p","^;","^3B","^20","~$a","^1B","^1E","^1N","^2V","^2<","~:else","^2Z","^1P","^30","^2O","^1S","^32","^35","^3J","^1J","^3L","^3N","~:max-chars-in-str","~:ns","^1V","^:","^17","^1Z","^T","^1G","~:first-val","^24","^J","~$v","^3T","^3X","^3V","^2P","^N","^1L","^41","~:branches","^3P","^21","^23","^26","^2U","^29","^1Q","^1=","^3@","^U","^16","^2;","^2@","^2R","^3F","^2D","^W","^2X","^2Q","^2F","^L","^2H","^13","^11","^1D","^2J","^2L","~$n","~$m","^34","^3Q","^1H","^2N","^2S","^1O","^1K","~:leaves","^1W","^1<","^2W","^2Y","^K","^2[","^31","^33","^3=","~:max-val","^[","^36","^14","~$s","^19","^2T","^3D","^38","~$k","^1>","^1@","^3H","^M","^3:","^22","^25","^3<","^28","^37","^18","^3>","^27","^X","^2=","^3A","^1M","^2C","^3C","^3E","^1[","^2E","^O","^3G","^1I","^2G","^1R","^1T","^2I","^R","^2B","^12","^3I","^1U","^3K","^3M","^S","^1Y","^1C","^3S","~$b","~:test","^3O","^1F","^3R","^3U","^3W","^3Y","~$d","~$f","^3["]],"~:order",["^1U","^48","^:","^J","^N","^L","^K","^M","^O","^R","^4=","^;","^1J","^14","^10","^11","^12","^13","^1R","^1P","^1Q","^3B","^3A","~$f","~$m","^3L","^3K","^2A","^2B","^3Z","^3Y","^2X","^2W","^2C","^2@","^3V","^3U","^2:","^29","~$x","^[","^Z","~$s","^35","^2<","^1L","^33","^T","^X","^U","^W","^1X","^1W","^34","^30","^2[","^2O","~$&","^3H","^3G","^24","~$a","^1T","^1S","^1<","~$k","~$v","~$n","^3N","^3M","^2I","^2H","^1O","^1N","^3F","^3E","^3T","^3R","^3S","^32","^31","~$b","^25","^23","^1@","^1?","^2V","^2S","^2T","^2U","^19","^15","^16","^17","^18","^1M","^1E","^1F","^1G","^1K","^1H","^1I","^49","^4<","^3D","^3C","^1=","^1>","^1;","~$d","^1D","^1A","^1B","^1C","^1Y","^1V","^3Q","^3O","^3P","^2G","^2F","^2E","^2D","^S","^G","^2M","^2L","^2Z","^2Y","^27","^28","^26","^4:","^4;","^37","^36","^3;","^3:","~$p","^3@","^3>","^3?","^2K","^2J","^3J","^3I","^20","^1Z","^1[","^2?","^2;","^2=","^2>","^41","^3[","^40","^3=","^3<","^3X","^3W","^22","^21","^39","^38","^2R","^2N","^2P","^2Q","^45","^47","^46"]],"^R",null]