["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$clojure.test.check","~:imports",null,"~:requires",["^ ","~$ct","~$clojure.test.check.clojure-test","~$rose","~$clojure.test.check.rose-tree","~$clojure.test.check.impl","^=","^<","^<","~$clojure.test.check.generators","^>","~$gen","^>","~$clojure.test.check.random","^@","^:","^:","~$random","^@"],"~:cljs.spec/speced-vars",[],"~:uses",["^ ","~$exception-like?","^=","~$get-current-time-millis","^="],"~:defs",["^ ","~$shrink-loop",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","^6","~:line",79,"~:column",8,"~:end-line",79,"~:end-column",19,"~:private",true,"~:arglists",["~#list",["~$quote",["^Q",[["~$rose-tree"]]]]],"~:doc","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found."],"^O",true,"^5","~$clojure.test.check/shrink-loop","~:variadic",false,"^J","clojure/test/check.cljc","^N",19,"~:method-params",["^Q",[["^S"]]],"~:protocol-impl",null,"~:arglists-meta",["^Q",[null,null]],"^L",1,"^K",79,"^M",79,"~:max-fixed-arity",1,"~:fn-var",true,"^P",["^Q",["^R",["^Q",[["^S"]]]]],"^T","Shrinking a value produces a sequence of smaller values of the same type.\n  Each of these values can then be shrunk. Think of this as a tree. We do a\n  modified depth-first search of the tree:\n\n  Do a non-exhaustive search for a deeper (than the root) failing example.\n  Additional rules added to depth-first search:\n  * If a node passes the property, you may continue searching at this depth,\n  but not backtrack\n  * If a node fails the property, search its children\n  The value returned is the left-most failing example at the depth where a\n  passing example was found."],"~$failure",["^ ","^H",null,"^I",["^ ","^J","^6","^K",112,"^L",8,"^M",112,"^N",15,"^O",true,"^P",["^Q",["^R",["^Q",[["~$property","~$failing-rose-tree","~$trial-number","~$size","~$seed"]]]]]],"^O",true,"^5","~$clojure.test.check/failure","^V",false,"^J","clojure/test/check.cljc","^N",15,"^W",["^Q",[["^11","^12","^13","^14","^15"]]],"^X",null,"^Y",["^Q",[null,null]],"^L",1,"^K",112,"^M",112,"^Z",5,"^[",true,"^P",["^Q",["^R",["^Q",[["^11","^12","^13","^14","^15"]]]]]],"~$make-rng",["^ ","^H",null,"^I",["^ ","^J","^6","^K",20,"^L",8,"^M",20,"^N",16,"^O",true,"^P",["^Q",["^R",["^Q",[["^15"]]]]]],"^O",true,"^5","~$clojure.test.check/make-rng","^V",false,"^J","clojure/test/check.cljc","^N",16,"^W",["^Q",[["^15"]]],"^X",null,"^Y",["^Q",[null,null]],"^L",1,"^K",20,"^M",20,"^Z",1,"^[",true,"^P",["^Q",["^R",["^Q",[["^15"]]]]]],"~$complete",["^ ","^H",null,"^I",["^ ","^J","^6","^K",27,"^L",8,"^M",27,"^N",16,"^O",true,"^P",["^Q",["^R",["^Q",[["^11","~$num-trials","^15"]]]]]],"^O",true,"^5","~$clojure.test.check/complete","^V",false,"^J","clojure/test/check.cljc","^N",16,"^W",["^Q",[["^11","^1:","^15"]]],"^X",null,"^Y",["^Q",[null,null]],"^L",1,"^K",27,"^M",27,"^Z",3,"^[",true,"^P",["^Q",["^R",["^Q",[["^11","^1:","^15"]]]]]],"~$not-falsey-or-exception?",["^ ","^H",null,"^I",["^ ","^J","^6","^K",32,"^L",8,"^M",32,"^N",32,"^O",true,"^P",["^Q",["^R",["^Q",[["~$value"]]]]],"^T","True if the value is not falsy or an exception"],"^O",true,"^5","~$clojure.test.check/not-falsey-or-exception?","^V",false,"^J","clojure/test/check.cljc","^N",32,"^W",["^Q",[["^1="]]],"^X",null,"^Y",["^Q",[null,null]],"^L",1,"^K",32,"^M",32,"^Z",1,"^[",true,"^P",["^Q",["^R",["^Q",[["^1="]]]]],"^T","True if the value is not falsy or an exception"],"~$quick-check",["^ ","^H",null,"^I",["^ ","^J","^6","^K",37,"^L",7,"^M",37,"^N",18,"^P",["^Q",["^R",["^Q",[["~$num-tests","^11","~$&",["^ ","~:keys",["^15","~$max-size"],"~:or",["^ ","^1B",200]]]]]]],"^T","Tests `property` `num-tests` times.\n  Takes optional keys `:seed` and `:max-size`. The seed parameter\n  can be used to re-run previous tests, as the seed used is returned\n  after a test is run. The max-size can be used to control the 'size'\n  of generated values. The size will start at 0, and grow up to\n  max-size, as the number of tests increases. Generators will use\n  the size parameter to bound their growth. This prevents, for example,\n  generating a five-thousand element vector on the very first test.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n      (quick-check 100 p)\n  ","~:top-fn",["^ ","^V",true,"^Z",2,"^W",[["^Q",["^1@","^11",["^ ","^1A",["^15","^1B"],"^1C",["^ ","^1B",200]]]]],"^P",["^Q",[["^1@","^11","~$&",["^ ","^1A",["^15","^1B"],"^1C",["^ ","^1B",200]]]]],"^Y",["^Q",[null]]]],"^5","~$clojure.test.check/quick-check","^V",true,"^J","clojure/test/check.cljc","^N",18,"^1D",["^ ","^V",true,"^Z",2,"^W",[["^Q",["^1@","^11",["^ ","^1A",["^15","^1B"],"^1C",["^ ","^1B",200]]]]],"^P",["^Q",[["^1@","^11","~$&",["^ ","^1A",["^15","^1B"],"^1C",["^ ","^1B",200]]]]],"^Y",["^Q",[null]]],"^W",[["^Q",["^1@","^11",["^ ","^1A",["^15","^1B"],"^1C",["^ ","^1B",200]]]]],"^X",null,"^Y",["^Q",[null]],"^L",1,"^K",37,"^M",37,"^Z",2,"^[",true,"^P",["^Q",[["^1@","^11","~$&",["^ ","^1A",["^15","^1B"],"^1C",["^ ","^1B",200]]]]],"^T","Tests `property` `num-tests` times.\n  Takes optional keys `:seed` and `:max-size`. The seed parameter\n  can be used to re-run previous tests, as the seed used is returned\n  after a test is run. The max-size can be used to control the 'size'\n  of generated values. The size will start at 0, and grow up to\n  max-size, as the number of tests increases. Generators will use\n  the size parameter to bound their growth. This prevents, for example,\n  generating a five-thousand element vector on the very first test.\n\n  Examples:\n\n      (def p (for-all [a gen/pos-int] (> (* a a) a)))\n      (quick-check 100 p)\n  "],"~$smallest-shrink",["^ ","^H",null,"^I",["^ ","^J","^6","^K",72,"^L",8,"^M",72,"^N",23,"^O",true,"^P",["^Q",["^R",["^Q",[["~$total-nodes-visited","~$depth","~$smallest"]]]]]],"^O",true,"^5","~$clojure.test.check/smallest-shrink","^V",false,"^J","clojure/test/check.cljc","^N",23,"^W",["^Q",[["^1G","^1H","^1I"]]],"^X",null,"^Y",["^Q",[null,null]],"^L",1,"^K",72,"^M",72,"^Z",3,"^[",true,"^P",["^Q",["^R",["^Q",[["^1G","^1H","^1I"]]]]]]],"~:cljs.spec/registry-ref",[],"~:require-macros",["^ "],"~:cljs.analyzer/constants",["^ ","~:seen",["^4",["~:args","~$&","^S","^19","^G","^17","~:shrunk","^1>","^1J","^1E","~:total-nodes-visited","^O","^12","~:ns","^5","^18","^V","^1C","^1;","^J","~:num-tests","^N","^1D","^U","^1G","~:max-size","^W","^1<","^10","^1F","^Y","~:seed","^11","^1?","^L","^6","^1=","^1@","~:fail","^1A","^K","^1B","~:result","^16","~:smallest","~:declared","~:failing-size","^15","^14","^M","^13","~:depth","^Z","^P","^T","^1I","~:test","^1:","^1H"]],"~:order",["^U","^1R","^5","^J","^N","^L","^K","^1Y","^M","^P","^T","^20","^6","^G","^16","^10","^18","^O","^17","^15","^1W","^1S","^1U","^1;","^19","^11","^1:","^1>","^1<","^1=","^1E","^1D","^1?","^V","^Z","^W","^Y","^1@","^1A","^1C","^1B","~$&","^1T","^1O","^1Q","^1[","^1X","^1J","^1F","^1G","^1H","^1I","^S","^1Z","^1V","^1P","^12","^13","^14"]],"^T",null]