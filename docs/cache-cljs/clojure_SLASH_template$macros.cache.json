["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$clojure.template$macros","~:imports",null,"~:requires",["^ ","~$walk","~$clojure.walk","^<","^<"],"~:uses",null,"~:defs",["^ ","~$apply-template",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","~$clojure.template","~:line",30,"~:column",7,"~:end-line",30,"~:end-column",21,"~:arglists",["~#list",["~$quote",["^I",[["~$argv","~$expr","~$values"]]]]],"~:doc","For use in macros.  argv is an argument list, as in defn.  expr is\n  a quoted expression using the symbols in argv.  values is a sequence\n  of values to be used for the arguments.\n\n  apply-template will recursively replace argument symbols in expr\n  with their corresponding values, returning a modified expr.\n\n  Example: (apply-template '[x] '(+ x x) '[2])\n           ;=> (+ 2 2)"],"^7","~$clojure.template$macros/apply-template","~:variadic",false,"^B","clojure/template.clj","^G",21,"~:method-params",["^I",[["^K","^L","^M"]]],"~:protocol-impl",null,"~:arglists-meta",["^I",[null,null]],"^E",1,"^D",30,"^F",30,"~:max-fixed-arity",3,"~:fn-var",true,"^H",["^I",["^J",["^I",[["^K","^L","^M"]]]]],"^N","For use in macros.  argv is an argument list, as in defn.  expr is\n  a quoted expression using the symbols in argv.  values is a sequence\n  of values to be used for the arguments.\n\n  apply-template will recursively replace argument symbols in expr\n  with their corresponding values, returning a modified expr.\n\n  Example: (apply-template '[x] '(+ x x) '[2])\n           ;=> (+ 2 2)"],"~$do-template",["^ ","^@",null,"^A",["^ ","^B","^C","^G",22,"~:top-fn",["^ ","^P",true,"^T",4,"^Q",[["^I",["~$&form","~$&env","^K","^L","^M"]]],"^H",["^I",[["^X","^Y","^K","^L","~$&","^M"]]],"^S",["^I",[null]]],"^E",11,"^D",45,"~:macro",true,"^F",45,"^H",["^I",["^J",["^I",[["^K","^L","~$&","^M"]]]]],"^N","Repeatedly copies expr (in a do block) for each group of arguments\n  in values.  values are automatically partitioned by the number of\n  arguments in argv, an argument vector as in defn.\n\n  Example: (macroexpand '(do-template [x y] (+ y x) 2 4 3 5))\n           ;=> (do (+ 4 2) (+ 5 3))"],"^7","~$clojure.template$macros/do-template","^P",true,"^B","clojure/template.clj","^G",22,"^W",["^ ","^P",true,"^T",4,"^Q",[["^I",["^X","^Y","^K","^L","^M"]]],"^H",["^I",[["^X","^Y","^K","^L","~$&","^M"]]],"^S",["^I",[null]]],"^Q",[["^I",["^X","^Y","^K","^L","^M"]]],"^R",null,"^S",["^I",[null]],"^E",1,"^D",45,"^Z",true,"^F",45,"^T",4,"^U",false,"^H",["^I",[["^X","^Y","^K","^L","~$&","^M"]]],"^N","Repeatedly copies expr (in a do block) for each group of arguments\n  in values.  values are automatically partitioned by the number of\n  arguments in argv, an argument vector as in defn.\n\n  Example: (macroexpand '(do-template [x y] (+ y x) 2 4 3 5))\n           ;=> (do (+ 4 2) (+ 5 3))"]],"~:require-macros",["^ "],"^N",null]