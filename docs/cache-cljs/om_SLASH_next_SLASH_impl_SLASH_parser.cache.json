["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$Error",["^ "]],"~:use-macros",["^ "],"~:excludes",["~#set",[]],"~:name","~$om.next.impl.parser","~:imports",null,"~:requires",["^ ","~$set","~$clojure.set","^<","^<","~$util","~$om.util","^>","^>"],"~:uses",null,"~:defs",["^ ","~$expr->ast",["^ ","~:protocol-inline",null,"~:meta",["^ ","~:file","^8","~:line",115,"~:column",7,"~:end-line",115,"~:end-column",16,"~:arglists",["~#list",["~$quote",["^J",[["~$x"]]]]],"~:doc","Given a query expression convert it into an AST."],"^7","~$om.next.impl.parser/expr->ast","~:variadic",false,"^D","om/next/impl/parser.cljc","^H",16,"~:method-params",["^J",[["~$x"]]],"~:protocol-impl",null,"~:arglists-meta",["^J",[null,null]],"^F",1,"^E",115,"^G",115,"~:max-fixed-arity",1,"~:fn-var",true,"^I",["^J",["^K",["^J",[["~$x"]]]]],"^L","Given a query expression convert it into an AST."],"~$call->ast",["^ ","^B",null,"^C",["^ ","^D","^8","^E",74,"^F",7,"^G",74,"^H",16,"^I",["^J",["^K",["^J",[[["~$f","~$args","~:as","~$call"]]]]]]],"^7","~$om.next.impl.parser/call->ast","^N",false,"^D","om/next/impl/parser.cljc","^H",16,"^O",["^J",[["~$p__37"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",74,"^G",74,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[[["~$f","^U","^V","^W"]]]]]]],"~$ast->expr",["^ ","^B",null,"^C",["^ ","^D","^8","^E",135,"^F",7,"^G",135,"^H",16,"^I",["^J",["^K",["^J",[["~$ast"],[["^ ","^V","^[","~:keys",["~$type","~$component"]],"~$unparse?"]]]]],"^L","Given a query expression AST convert it back into a query expression.","~:top-fn",["^ ","^N",false,"^R",2,"^O",["^J",[["^["],[["^ ","^V","^[","^10",["^11","^12"]],"^13"]]],"^I",["^J",[["^["],[["^ ","^V","^[","^10",["^11","^12"]],"^13"]]],"^Q",["^J",[null,null]]]],"^7","~$om.next.impl.parser/ast->expr","^N",false,"^D","om/next/impl/parser.cljc","^H",16,"^14",["^ ","^N",false,"^R",2,"^O",["^J",[["^["],[["^ ","^V","^[","^10",["^11","^12"]],"^13"]]],"^I",["^J",[["^["],[["^ ","^V","^[","^10",["^11","^12"]],"^13"]]],"^Q",["^J",[null,null]]],"^O",["^J",[["^["],[["^ ","^V","^[","^10",["^11","^12"]],"^13"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",135,"^G",135,"^R",2,"^S",true,"^I",["^J",[["^["],[["^ ","^V","^[","^10",["^11","^12"]],"^13"]]],"^L","Given a query expression AST convert it back into a query expression."],"~$rethrow?",["^ ","^B",null,"^C",["^ ","^D","^8","^E",237,"^F",7,"^G",237,"^H",15,"^I",["^J",["^K",["^J",[["~$x"]]]]]],"^7","~$om.next.impl.parser/rethrow?","^N",false,"^D","om/next/impl/parser.cljc","^H",15,"^O",["^J",[["~$x"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",237,"^G",237,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[["~$x"]]]]]],"~$path-meta",["^ ","^B",null,"^C",["^ ","^D","^8","^E",167,"^F",7,"^G",167,"^H",16,"^I",["^J",["^K",["^J",[["~$data","~$path","~$query"],["^19","^1:","^1;","~$union-expr"]]]]],"^L","Add path metadata to a data structure. data is the data to be worked on.\n   path is the current path into the data. query is the query used to\n   walk the data. union-expr tracks the last seen union query to be used\n   when it finds a recursive union.","^14",["^ ","^N",false,"^R",4,"^O",["^J",[["^19","^1:","^1;"],["^19","^1:","^1;","^1<"]]],"^I",["^J",[["^19","^1:","^1;"],["^19","^1:","^1;","^1<"]]],"^Q",["^J",[null,null]]]],"^7","~$om.next.impl.parser/path-meta","^N",false,"^D","om/next/impl/parser.cljc","^H",16,"^14",["^ ","^N",false,"^R",4,"^O",["^J",[["^19","^1:","^1;"],["^19","^1:","^1;","^1<"]]],"^I",["^J",[["^19","^1:","^1;"],["^19","^1:","^1;","^1<"]]],"^Q",["^J",[null,null]]],"^O",["^J",[["^19","^1:","^1;"],["^19","^1:","^1;","^1<"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",167,"^G",167,"^R",4,"^S",true,"^I",["^J",[["^19","^1:","^1;"],["^19","^1:","^1;","^1<"]]],"^L","Add path metadata to a data structure. data is the data to be worked on.\n   path is the current path into the data. query is the query used to\n   walk the data. union-expr tracks the last seen union query to be used\n   when it finds a recursive union."],"~$wrap-expr",["^ ","^B",null,"^C",["^ ","^D","^8","^E",128,"^F",7,"^G",128,"^H",16,"^I",["^J",["^K",["^J",[["~$root?","~$expr"]]]]]],"^7","~$om.next.impl.parser/wrap-expr","^N",false,"^D","om/next/impl/parser.cljc","^H",16,"^O",["^J",[["^1?","^1@"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",128,"^G",128,"^R",2,"^S",true,"^I",["^J",["^K",["^J",[["^1?","^1@"]]]]]],"~$join->ast",["^ ","^B",null,"^C",["^ ","^D","^8","^E",91,"^F",7,"^G",91,"^H",16,"^I",["^J",["^K",["^J",[["~$join"]]]]]],"^7","~$om.next.impl.parser/join->ast","^N",false,"^D","om/next/impl/parser.cljc","^H",16,"^O",["^J",[["^1C"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",91,"^G",91,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[["^1C"]]]]]],"~$keyword->ast",["^ ","^B",null,"^C",["^ ","^D","^8","^E",54,"^F",7,"^G",54,"^H",19,"^I",["^J",["^K",["^J",[["~$k"]]]]]],"^7","~$om.next.impl.parser/keyword->ast","^N",false,"^D","om/next/impl/parser.cljc","^H",19,"^O",["^J",[["~$k"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",54,"^G",54,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[["~$k"]]]]]],"~$query->ast",["^ ","^B",null,"^C",["^ ","^D","^8","^E",81,"^F",7,"^G",81,"^H",17,"^I",["^J",["^K",["^J",[["^1;"]]]]],"^L","Convert a query to its AST representation."],"^7","~$om.next.impl.parser/query->ast","^N",false,"^D","om/next/impl/parser.cljc","^H",17,"^O",["^J",[["^1;"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",81,"^G",81,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[["^1;"]]]]],"^L","Convert a query to its AST representation."],"~$ident->ast",["^ ","^B",null,"^C",["^ ","^D","^8","^E",110,"^F",7,"^G",110,"^H",17,"^I",["^J",["^K",["^J",[[["~$k","~$id","^V","~$ref"]]]]]]],"^7","~$om.next.impl.parser/ident->ast","^N",false,"^D","om/next/impl/parser.cljc","^H",17,"^O",["^J",[["~$p__52"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",110,"^G",110,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[[["~$k","^1J","^V","^1K"]]]]]]],"~$dispatch",["^ ","^B",null,"^C",["^ ","^D","^8","^E",296,"^F",7,"^G",296,"^H",15,"^I",["^J",["^K",["^J",[["~$_","~$k","~$_"]]]]]],"^7","~$om.next.impl.parser/dispatch","^N",false,"^D","om/next/impl/parser.cljc","^H",15,"^O",["^J",[["~$_","~$k","~$_"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",296,"^G",296,"^R",3,"^S",true,"^I",["^J",["^K",["^J",[["~$_","~$k","~$_"]]]]]],"~$union-entry->ast",["^ ","^B",null,"^C",["^ ","^D","^8","^E",59,"^F",7,"^G",59,"^H",23,"^I",["^J",["^K",["^J",[[["~$k","~$v"]]]]]]],"^7","~$om.next.impl.parser/union-entry->ast","^N",false,"^D","om/next/impl/parser.cljc","^H",23,"^O",["^J",[["~$p__30"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",59,"^G",59,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[[["~$k","~$v"]]]]]]],"~$parser",["^ ","^B",null,"^C",["^ ","^D","^8","^E",241,"^F",7,"^G",241,"^H",13,"^I",["^J",["^K",["^J",[[["^ ","^V","~$config","^10",["~$read","~$mutate"]]]]]]],"^L","Given a :read and/or :mutate function return a parser. Refer to om.next/parser\n   for top level documentation."],"^7","~$om.next.impl.parser/parser","^N",false,"^D","om/next/impl/parser.cljc","^H",13,"^O",["^J",[["~$p__104"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",241,"^G",241,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[[["^ ","^V","^1T","^10",["^1U","^1V"]]]]]]],"^L","Given a :read and/or :mutate function return a parser. Refer to om.next/parser\n   for top level documentation."],"~$symbol->ast",["^ ","^B",null,"^C",["^ ","^D","^8","^E",50,"^F",7,"^G",50,"^H",18,"^I",["^J",["^K",["^J",[["~$k"]]]]]],"^7","~$om.next.impl.parser/symbol->ast","^N",false,"^D","om/next/impl/parser.cljc","^H",18,"^O",["^J",[["~$k"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",50,"^G",50,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[["~$k"]]]]]],"~$union->ast",["^ ","^B",null,"^C",["^ ","^D","^8","^E",69,"^F",7,"^G",69,"^H",17,"^I",["^J",["^K",["^J",[["~$m"]]]]]],"^7","~$om.next.impl.parser/union->ast","^N",false,"^D","om/next/impl/parser.cljc","^H",17,"^O",["^J",[["~$m"]]],"^P",null,"^Q",["^J",[null,null]],"^F",1,"^E",69,"^G",69,"^R",1,"^S",true,"^I",["^J",["^K",["^J",[["~$m"]]]]]]],"~:require-macros",null,"~:cljs.analyzer/constants",["^ ","~:seen",["^6",["^17","^X","~:query-root","~:path","^15","~$x","~:remote","^A","^1;","~:children","^T","^Z","~:union-key","^1C","~:read","~:key","^1V","~:union-entry","^19","~:else","~:call","^16","^1:","^13","^U","^8","~:ns","^7","^V","^N","~$*","^1?","~:value","^D","~$v","^H","^14","~:params","~:ast","^1U","~:type","^O","^W","~$_","~:component","^1K","^Q","~:error/invalid-join","^1T","^F","^M","^20","~:error/invalid-expression","^18","~$m","~:om.next/abort","^1>","^1F","^1B","~:parser","^10","^1<","^1H","^E","^[","~:root","^11","~:result","^1D","^1E","~:prop","^1L","^12","^1G","~:declared","~$k","^1I","~:dispatch-key","~:om-path","^G","~:action","^1N","^1P","^R","^1S","~:target","^K","^I","^1Q","~:query","^1@","^1J","~:om.next/error","~:union","^1W","~$...","^L","^1Y","~:test","~:mutate","~:om.next/root","^1O","^1Z","^1[","^1=","~:join","~:elide-paths","^1A","~$f"]],"~:order",["^M","^2>","^7","^D","^H","^F","^E","^2K","^G","^I","^L","^2T","^8","^A","^2:","^2L","^1Z","^1Y","~$k","^2B","^2J","^1F","^1E","^2C","^27","^28","^2P","^2;","^1Q","^1P","~$v","^2R","^20","^1[","~$m","^K","^2O","^26","^2@","^2=","^X","^T","~$f","^U","^V","^W","^2H","^1H","^1G","^1;","^24","^2W","^2S","^2<","^2D","^1D","^1B","^1C","^1L","^1I","^1J","^1K","^2E","~$x","^1A","^1>","^1?","^1@","^15","^14","^Z","^N","^R","^O","^Q","^[","^10","^11","^12","^13","^1=","^18","^19","^1:","^1<","^2M","~$*","^2F","^17","^16","^2U","^29","^2X","^2G","^2V","^25","^2A","^2?","^2N","^2I","^2Q","^1W","^1S","^1T","^1U","^1V","^1O","^1N","~$_"]],"^L","\n   Generic query expression parsing and AST manipulation.\n\n   QUERY EXPRESSIONS\n\n   Query expressions are a variation on Datomic Pull Syntax\n   http://docs.datomic.com/pull.html more suitable for generic client/server\n   state transfer. It's important to note the Om Next query expression syntax is\n   *not* a strict superset of Datomic Pull.\n\n   A query expression is composed of EDN values. The grammar for query\n   expressions follows:\n\n   QueryRoot      := EdnVector(QueryExpr*)\n   PlainQueryExpr := (EdnKeyword | IdentExpr | JoinExpr)\n   QueryExpr      := (PlainQueryExpr | ParamExpr)\n   IdentExpr      := EdnVector2(Keyword, EdnValue)\n   ParamExpr      := EdnList2(PlainQueryExpr | EdnSymbol, ParamMapExpr)\n   ParamMapExpr   := EdnMap(Keyword, EdnValue)\n   JoinExpr       := EdnMap((Keyword | IdentExpr), (QueryRoot | UnionExpr | RecurExpr))\n   UnionExpr      := EdnMap(Keyword, QueryRoot)\n   RecurExpr      := ('... | Integer)\n\n   Note most apis in Om Next expect a QueryRoot not a QueryExpr.\n\n   QUERY EXPRESSION AST FORMAT\n\n   Given a QueryExpr you can get the AST via om.next.impl.parser/expr->ast.\n   The following keys can appear in the AST representation:\n\n   {:type         (:prop | :join | :call | :root | :union | :union-entry)\n    :key          (EdnKeyword | EdnSymbol | IdentExpr)\n    :dispatch-key (EdnKeyword | EdnSymbol)\n    :union-key    EdnKeyword\n    :query        (QueryRoot | RecurExpr)\n    :params       ParamMapExpr\n    :children     EdnVector(AST)\n    :component    Object\n    :target       EdnKeyword}\n\n   :query and :params may or may not appear. :type :call is only for\n   mutations."]