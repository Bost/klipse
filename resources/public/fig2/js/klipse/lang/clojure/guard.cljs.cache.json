["^ ","~:rename-macros",["^ "],"~:renames",["^ "],"~:externs",["^ ","~$confirm",["^ "]],"~:use-macros",["^ ","~$starts-with?","~$clojure.string","~$go","~$cljs.core.async.macros","~$dbg","~$gadjett.core","~$go-loop","^8","~$emits","~$cljs.compiler","~$*source-map-data*","^=","~$emit","^="],"~:excludes",["~#set",[]],"~:name","~$klipse.lang.clojure.guard","~:imports",null,"~:requires",["^ ","~$klipse.utils","^F","~$ana","~$cljs.analyzer","^H","^H","~$s","^6","^6","^6","^=","^=","~$cljs.core.async","^I"],"~:uses",["^ ","~$timeout","^I","~$<!","^I","^5","^6","~$chan","^I","~$runonce","^F","^<","^=","^>","^=","^?","^=","~$put!","^I"],"~:defs",["^ ","~$*watchdog-tick*",["^ ","~:meta",["^ ","~:file","/Users/viebel/prj/klipse/src/klipse/lang/clojure/guard.cljs","~:line",20,"~:column",3,"~:end-line",20,"~:end-column",18,"~:doc","each time the watchdog has a chance to run, this var is set with the current time","~:dynamic",true],"^B","~$klipse.lang.clojure.guard/*watchdog-tick*","^S","/Users/viebel/prj/klipse/src/klipse/lang/clojure/guard.cljs","^W",18,"^U",1,"^Y",true,"^T",18,"^V",20,"~:tag","~$number","^X","each time the watchdog has a chance to run, this var is set with the current time"],"~$min-max-eval-duration",["^ ","^B","~$klipse.lang.clojure.guard/min-max-eval-duration","^S","/Users/viebel/prj/klipse/src/klipse/lang/clojure/guard.cljs","^T",22,"^U",1,"^V",22,"^W",27,"^R",["^ ","^S","/Users/viebel/prj/klipse/src/klipse/lang/clojure/guard.cljs","^T",22,"^U",6,"^V",22,"^W",27],"^[","^10"],"~$watchdog-period",["^ ","^B","~$klipse.lang.clojure.guard/watchdog-period","^S","/Users/viebel/prj/klipse/src/klipse/lang/clojure/guard.cljs","^T",23,"^U",1,"^V",25,"^W",18,"^X","The number of msec for the watchdog period.\n            This value has to be much lower than min-max-eval-duration.","^R",["^ ","^S","/Users/viebel/prj/klipse/src/klipse/lang/clojure/guard.cljs","^T",25,"^U",3,"^V",25,"^W",18,"^X","The number of msec for the watchdog period.\n            This value has to be much lower than min-max-eval-duration."],"^[","^10"],"~$tick",["^ ","~:protocol-inline",null,"^R",["^ ","^S","/Users/viebel/prj/klipse/src/klipse/lang/clojure/guard.cljs","^T",27,"^U",7,"^V",27,"^W",11,"~:arglists",["~#list",["~$quote",["^18",[[]]]]]],"^B","~$klipse.lang.clojure.guard/tick","~:variadic",false,"^S","/Users/viebel/prj/klipse/src/klipse/lang/clojure/guard.cljs","^W",11,"~:method-params",["^18",[[]]],"~:protocol-impl",null,"~:arglists-meta",["^18",[null,null]],"^U",1,"^T",27,"^V",27,"~:max-fixed-arity",0,"~:fn-var",true,"^17",["^18",["^19",["^18",[[]]]]]],"~$run-watchdog*",["^ ","^16",null,"^R",["^ ","^S","/Users/viebel/prj/klipse/src/klipse/lang/clojure/guard.cljs","^T",30,"^U",7,"^V",30,"^W",20,"^17",["^18",["^19",["^18",[[]]]]],"^X","reset the *watchdog-tick* to the current time once in a while"],"^B","~$klipse.lang.clojure.guard/run-watchdog*","^1;",false,"^S","/Users/viebel/prj/klipse/src/klipse/lang/clojure/guard.cljs","^W",20,"^1<",["^18",[[]]],"^1=",null,"^1>",["^18",[null,null]],"^U",1,"^T",30,"^V",30,"^1?",0,"^1@",true,"^17",["^18",["^19",["^18",[[]]]]],"^X","reset the *watchdog-tick* to the current time once in a while"],"~$run-watchdog-once",["^ ","^B","~$klipse.lang.clojure.guard/run-watchdog-once","^S","/Users/viebel/prj/klipse/src/klipse/lang/clojure/guard.cljs","^T",39,"^U",1,"^V",39,"^W",23,"^R",["^ ","^S","/Users/viebel/prj/klipse/src/klipse/lang/clojure/guard.cljs","^T",39,"^U",6,"^V",39,"^W",23],"^[","~$any"],"~$watchdog",["^ ","^16",null,"^R",["^ ","^S","/Users/viebel/prj/klipse/src/klipse/lang/clojure/guard.cljs","^T",41,"^U",7,"^V",41,"^W",15,"^17",["^18",["^19",["^18",[[]]]]]],"^B","~$klipse.lang.clojure.guard/watchdog","^1;",false,"^S","/Users/viebel/prj/klipse/src/klipse/lang/clojure/guard.cljs","^W",15,"^1<",["^18",[[]]],"^1=",null,"^1>",["^18",[null,null]],"^U",1,"^T",41,"^V",41,"^1?",0,"^1@",true,"^17",["^18",["^19",["^18",[[]]]]]],"~$guard",["^ ","^16",null,"^R",["^ ","^S","/Users/viebel/prj/klipse/src/klipse/lang/clojure/guard.cljs","^T",46,"^U",3,"^V",46,"^W",8,"~:export",true,"^17",["^18",["^19",["^18",[["~$max-eval-duration"]]]]]],"^B","~$klipse.lang.clojure.guard/guard","^1;",false,"^S","/Users/viebel/prj/klipse/src/klipse/lang/clojure/guard.cljs","^W",8,"^1<",["^18",[["^1J"]]],"^1=",null,"^1I",true,"^1>",["^18",[null,null]],"^U",1,"^T",45,"^V",46,"^1?",1,"^1@",true,"^17",["^18",["^19",["^18",[["^1J"]]]]]],"~$my-emits",["^ ","^16",null,"^R",["^ ","^S","/Users/viebel/prj/klipse/src/klipse/lang/clojure/guard.cljs","^T",53,"^U",7,"^V",53,"^W",15,"^17",["^18",["^19",["^18",[["^1J","~$&","~$xs"]]]]],"^X","same as cljs.compiler/emits with insertion of a `guard()` call before if and recur (emitted as continue) statement.\n\n  Limitations:\n  1. It doesn't prevent infinite loop in imported code e.g. (reduce + (range)\n  ","~:top-fn",["^ ","^1;",true,"^1?",1,"^1<",[["^18",["^1J","^1M"]]],"^17",["^18",[["^1J","~$&","^1M"]]],"^1>",["^18",[null]]]],"^B","~$klipse.lang.clojure.guard/my-emits","^1;",true,"^S","/Users/viebel/prj/klipse/src/klipse/lang/clojure/guard.cljs","^W",15,"^1N",["^ ","^1;",true,"^1?",1,"^1<",[["^18",["^1J","^1M"]]],"^17",["^18",[["^1J","~$&","^1M"]]],"^1>",["^18",[null]]],"^1<",[["^18",["^1J","^1M"]]],"^1=",null,"^1>",["^18",[null]],"^U",1,"^T",53,"^V",53,"^1?",1,"^1@",true,"^17",["^18",[["^1J","~$&","^1M"]]],"^X","same as cljs.compiler/emits with insertion of a `guard()` call before if and recur (emitted as continue) statement.\n\n  Limitations:\n  1. It doesn't prevent infinite loop in imported code e.g. (reduce + (range)\n  "]],"~:require-macros",["^ ","~$gadjett","^:","^:","^:","^8","^8"],"~:cljs.analyzer/constants",["^ ","~:seen",["^A",["~:else","~:recur","~:gen-col"]],"~:order",["^1U","^1T","^1V"]],"^X","The basic idea is that the first time a klipse snippet's cljs is evaluated, we kick off a go-loop whose job is to wake up every 100ms and update *watchdog-tick* to say: this is the last time that i woke up!\n\n  And if (guard) gets run and notices that the watchdog hasn't been able to wake up within the last *max-eval-duration* milliseconds, it decides that we should kill the currently evaluating function, and does that by throwing an error.\n\n  and this doesn't kill go-loops created by users' snippet code, because those go-loops won't block the watchdog from running.\n  "]